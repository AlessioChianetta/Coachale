Il tuo programmatore ha centrato diagnosi e direzione: passare da Map in memoria a stato su DB + transazioni è la mossa giusta.

Detto questo, c’è un punto importante: la sola “UPDATE atomica per token” non basta a prevenire i double booking se due token diversi possono esistere per lo stesso slot. Devi mettere un “muro” anche sullo slot (non solo sul token).

Cosa fare per renderlo davvero “a prova di produzione”
1) Persistenza su DB ✅

Sì: pending_bookings (o riuso/estensione della tua bookingExtractionState) risolve:

riavvii server / multi-instance

hasPendingBooking leggibile dal classifier/router

audit e debug

2) Anti double-booking: vincolo sullo slot (non solo sul token) ✅✅

Se oggi due utenti fanno proposeBooking sullo stesso orario, potrebbero entrambi ricevere un token diverso.
Poi:

confirmBooking fa UPDATE su token A → ok

confirmBooking fa UPDATE su token B → ok
Risultato: due consultazioni allo stesso slot.

Per evitare questo servono due livelli di protezione:

A. Vincolo unico “finale” sulla tabella consultations (hard safety)

unique su (consultant_id, start_at) (o date+time)

B. Vincolo unico “hold” sulla tabella pending_bookings (soft safety)

unique su (consultant_id, start_at) quando status = awaiting_confirm

Nota DB: il partial unique index dipende dal DB; se sei su Postgres è perfetto. Se non hai partial index, si può fare con tabella “slot_holds” separata o lock transazionale.

3) Propose/Confirm devono essere transazionali + lock ✅

Il pattern robusto è:

proposeBooking

calcola start_at (timestamp) da date+time

(in transazione) acquisisci lock su (consultant_id, start_at) (advisory lock o equivalente)

verifica:

non esiste già una consultation su quello slot

non esiste già una pending “awaiting_confirm” su quello slot

INSERT pending con status awaiting_confirm

commit

confirmBooking

(in transazione) UPDATE pending:

WHERE token=? AND status='awaiting_confirm' AND expires_at > now()

SET status='confirmed', confirmed_at=now()

RETURNING *

lock su (consultant_id, start_at) (stesso schema di prima)

INSERT su consultations (protetta anche da unique constraint)

salva consultation_id sulla pending (utile per idempotenza)

commit

Se l’INSERT su consultations fallisce per unique constraint → vuol dire “slot già preso”: aggiorni pending a cancelled/expired e ritorni errore pulito.

4) Idempotenza (ti evita bug “confermo due volte”) ✅

Aggiungi su pending_bookings:

consultation_id nullable

Così confirmBooking se trova status='confirmed' può semplicemente ritornare la stessa consultation_id invece di creare doppioni.

5) Expiry vera (non “expires_at > now()” nei vincoli) ✅

Il trucco pratico: non mettere now() negli indici/constraint (spesso non è “immutabile”).
Fai così:

status awaiting_confirm è considerato “attivo”

job/cron ogni 1–5 minuti: UPDATE pending_bookings SET status='expired' WHERE status='awaiting_confirm' AND expires_at < now()

6) Collegamento col tuo problema “esce dal tool” ✅

Questa migrazione risolve anche quello, perché finalmente puoi fare:

in ai-service.ts prima di decidere tools:

SELECT pending_bookings WHERE conversation_id=? AND status='awaiting_confirm' AND expires_at>now() LIMIT 1

se esiste → tool mode “sticky” anche se l’utente scrive solo “ok / va bene / sì”

In più, puoi far sì che confirmBooking accetti anche solo conversation_id:

se manca token, prendi “latest pending per conversation+client” (e impedisci conferme cross-user controllando client_id)

Schema DB migliorato (minimo ma solido)

Invece di date + time, io metterei start_at (timestamp) per semplificare vincoli e confronti:

token (PK)

client_id

consultant_id

start_at (timestamp)

duration

status (awaiting_confirm | confirmed | expired | cancelled)

conversation_id / public_conversation_id

created_at

expires_at

confirmed_at

consultation_id (nullable)

Indici:

(conversation_id, status) per lookup veloce “hasPendingBooking”

unique su (consultant_id, start_at) dove status='awaiting_confirm' (se possibile)

unique su consultations(consultant_id, start_at) (sempre)

Bottom line

✅ La proposta del programmatore è giusta.
⚠️ Ma senza vincolo/lock sullo slot rischi ancora double booking.
✅ Con: DB + transazioni + unique constraint + sticky state, il flow diventa stabile e il classifier non “perde il contesto”.