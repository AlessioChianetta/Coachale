ðŸ“‹ ANALISI TECNICA COMPLETA
âŒ PROBLEMA 1: ICE Restart Non Implementato
File: client/src/hooks/useWebRTC.ts, linee 214-277

Codice attuale:

pc.oniceconnectionstatechange = () => {
  if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
    // cleanup OK
  } else if (pc.iceConnectionState === 'failed') {
    // retry con nuova connessione
  }
  // âš ï¸ MANCA: gestione di 'disconnected'
};

Problema: Quando lo stato ICE diventa disconnected:

Il codice non fa nulla
Aspetta passivamente che diventi failed (30+ secondi)
Nel frattempo: Remote streams: 0
Fix richiesto: Aggiungere ICE Restart:

} else if (pc.iceConnectionState === 'disconnected') {
  console.warn(`âš ï¸ [WebRTC] ICE disconnected, attempting restart...`);
  const restartConnection = async () => {
    try {
      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);
      sendWebRTCMessage({
        type: 'webrtc_offer',
        targetParticipantId: remoteParticipantId,
        fromParticipantId: myParticipantId,
        sdp: { type: 'offer', sdp: offer.sdp },
      });
    } catch (err) {
      console.error('ICE restart failed:', err);
    }
  };
  restartConnection();
}

âŒ PROBLEMA 2: Nessun beforeunload Handler
File: client/src/components/video-room/VideoRoom.tsx, linee 216-222

Codice attuale:

useEffect(() => {
  return () => {
    if (myParticipantIdRef.current) {
      leaveParticipant(myParticipantIdRef.current);
    }
  };
}, [leaveParticipant]);

Problema: Il cleanup su unmount NON funziona per il reload perchÃ©:

React esegue unmount ma il messaggio WebSocket potrebbe non arrivare in tempo
Il browser chiude la connessione prima che il messaggio sia inviato
Non c'Ã¨ beforeunload handler
Fix richiesto: Aggiungere in VideoRoom.tsx:

useEffect(() => {
  const handleBeforeUnload = () => {
    // Usa sendBeacon per garantire delivery
    if (myParticipantIdRef.current && meeting?.id) {
      navigator.sendBeacon(
        '/api/video-meeting/force-leave',
        JSON.stringify({
          participantId: myParticipantIdRef.current,
          meetingId: meeting.id,
        })
      );
    }
  };
  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [meeting?.id]);

âŒ PROBLEMA 3: Race Condition Zombie al Reload
File: server/websocket/video-ai-copilot.ts, funzione handleParticipantJoin (linee 2400-2513)

Codice attuale:

const [inactiveExisting] = await db.select()
  .from(videoMeetingParticipants)
  .where(and(
    eq(videoMeetingParticipants.meetingId, session.meetingId),
    eq(videoMeetingParticipants.name, name),
    eq(videoMeetingParticipants.role, role),
    isNotNull(videoMeetingParticipants.leftAt) // âš ï¸ Solo inactive!
  ))

Problema (Race Condition):

Utente "Mario" connesso come participant_abc
Mario fa F5 (reload)
Nuovo WebSocket arriva e chiama participant_join
Vecchio WebSocket sta ancora chiudendo (async)
Query cerca leftAt IS NOT NULL â†’ non trova abc (ancora attivo!)
Crea nuovo participant participant_xyz
Vecchio unregisterParticipantBySocket marca abc come left
Risultato: DUE entries, abc Ã¨ zombie morto, xyz Ã¨ il nuovo
Fix richiesto: Prima di creare nuovo participant, pulire zombie attivi:

async function handleParticipantJoin(...) {
  // STEP 1: Pulisci zombie ATTIVI (stesso nome/role, leftAt NULL, ma NESSUN socket)
  const [activeZombie] = await db.select()
    .from(videoMeetingParticipants)
    .where(and(
      eq(videoMeetingParticipants.meetingId, session.meetingId),
      eq(videoMeetingParticipants.name, name),
      eq(videoMeetingParticipants.role, role),
      isNull(videoMeetingParticipants.leftAt) // Attivo nel DB
    ))
    .limit(1);
  if (activeZombie) {
    const hasSocket = participantSockets.get(session.meetingId)?.has(activeZombie.id);
    if (!hasSocket) {
      // Ãˆ uno zombie! Il suo socket Ã¨ morto ma leftAt non Ã¨ stato settato
      console.log(`ðŸ§¹ [VideoCopilot] Cleaning active zombie: ${name} (${activeZombie.id})`);
      await db.update(videoMeetingParticipants)
        .set({ leftAt: new Date() })
        .where(eq(videoMeetingParticipants.id, activeZombie.id));
      session.participants.delete(activeZombie.id);
      // Broadcast che Ã¨ uscito
      broadcast({ type: 'participant_left', data: { id: activeZombie.id, ... } });
    }
  }
  // STEP 2: Ora cerca inactive da riciclare (codice esistente)
  const [inactiveExisting] = await db.select()...

âŒ PROBLEMA 4: Endpoint force-leave Mancante
Fix richiesto: Creare nuovo endpoint in server/routes.ts:

app.post("/api/video-meeting/force-leave", async (req, res) => {
  const { participantId, meetingId } = req.body;
  
  if (!participantId || !meetingId) {
    return res.status(400).json({ error: 'Missing data' });
  }
  
  try {
    await db.update(videoMeetingParticipants)
      .set({ leftAt: new Date() })
      .where(eq(videoMeetingParticipants.id, participantId));
    
    // Cleanup socket maps
    const meetingSockets = participantSockets.get(meetingId);
    if (meetingSockets) {
      meetingSockets.delete(participantId);
    }
    
    console.log(`ðŸ”¥ [ForceLeave] Cleaned up ${participantId} via beacon`);
    res.status(200).json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Cleanup failed' });
  }
});