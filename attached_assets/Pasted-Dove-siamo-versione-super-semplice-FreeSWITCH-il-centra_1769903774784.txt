Dove siamo (versione super semplice)

FreeSWITCH Ã¨ il â€œcentralinoâ€ che riceve la chiamata.

Il Bridge Node.js Ã¨ il â€œtraduttoreâ€ che prende lâ€™audio della chiamata e lo manda allâ€™AI (Replit/Gemini) e poi rimanda indietro la voce.

Replit resta â€œil cervello/appâ€: DB + context + collegamento a Gemini (come nel browser).

Quindi: manca solo che il ponte (Bridge) funzioni davvero e che FreeSWITCH gli mandi lâ€™audio nel modo giusto.

âœ… Cose OK nei tuoi file
1) Dialplan dialplan-9999.xml

Hai giÃ  messo la cosa giusta:

usa audio_stream (non socket)

manda a ws://127.0.0.1:9090

imposta codec PCMU (Î¼-law 8k) â†’ perfetto per telefonia

ğŸ‘‰ Questo Ã¨ corretto SE FreeSWITCH e il bridge stanno sulla stessa VPS (come nel tuo caso).

2) Service systemd alessia-voice.service

Impostazione sensata:

parte da /opt/alessia-voice

restart automatico

user dedicato

âœ… Buono.

3) voice-bridge-server.ts

Ha giÃ :

WebSocket server (porta 9090)

endpoint /health e /stats

gestione messaggi JSON (â€œstart/stop/dtmfâ€) + audio binario

âœ… Struttura giusta.

âŒ Cose che NON vanno (qui ti si romperÃ  tutto)

Questa Ã¨ la parte importante da riferire al programmatore: cosÃ¬ comâ€™Ã¨ non compila / non gira.

Problema A â€” config.ts NON ha config.session, ma il codice lo usa ovunque

Nei file:

index.ts

voice-bridge-server.ts

session-manager.ts

si legge config.session.maxConcurrent e config.session.timeoutMs, ma in config.ts non esiste session.

âœ… Soluzione semplice (da dire al programmatore):

o aggiunge session dentro config.ts

o cambia il codice per usare config.audio.maxConcurrentCalls e config.audio.maxCallDurationMs (che giÃ  esistono).

Io farei la soluzione piÃ¹ veloce: aggiungere session in config.ts cosÃ¬ non deve toccare 3 file.

Problema B â€” SessionManager salva le sessioni con chiave callId, ma poi prova a cancellarle con session.id

In session-manager.ts:

this.sessions.set(callId, session) âœ…

ma endSession(sessionId) fa this.sessions.delete(sessionId) âŒ

Quindi non cancella mai, e ti ritrovi sessioni â€œzombieâ€ (memory leak) + limiti â€œmax concurrentâ€ sballati.

âœ… Soluzione semplice (da dire al programmatore):

Decidere una sola chiave:

o usiamo sempre callId

o usiamo sempre session.id

Ma visto che FreeSWITCH ti parla sempre in callId/uuid, la cosa piÃ¹ pulita Ã¨:

mappa principale: callId -> session

endSession(callId, reason) elimina per callId

in voice-bridge-server.ts quando chiude, chiamare endSession(callId, ...) (non session.id)

Problema C â€” autenticazione WS (se metti 0.0.0.0)

Nel tuo .env.example câ€™Ã¨ WS_AUTH_TOKEN, ma nel codice non viene verificato.
Se il server ascolta su 0.0.0.0:9090, chiunque su internet puÃ² attaccarsi.

âœ… Per test:

lascia il bridge su 127.0.0.1 e fine.

âœ… Se vuoi â€œpubblicoâ€:

bridge su 0.0.0.0

UFW consenti 9090 solo dal tuo IP

e implementare check token (banale) nel WS handshake o nel primo messaggio.

Risposta alla tua domanda su â€œ127 vs IP pubblicoâ€

127.0.0.1 = â€œquesta stessa macchinaâ€.

FreeSWITCH â†’ Bridge (stessa VPS) = usa 127.0.0.1 âœ…

Bridge â†’ Replit (internet) = usa URL pubblico Replit âœ…

Se tu sei fuori casa e vuoi â€œentrareâ€ nel 127 della VPS:

non devi aprire tutto al mondo

fai un tunnel SSH e sei a posto.