üó∫Ô∏è ROADMAP COMPLETA: Unificazione Analytics Venditori Umani + AI
üìã INDICE
Fase	Descrizione	Tipo
1	Schema Database - Tabella persistenza umani	Backend
2	Funzioni Save/Load stato sessione	Backend
3	Integrazione salvataggio nei punti chiave	Backend
4	Recovery stato al riconnessione	Backend
5	API endpoints umani (stesso formato AI)	Backend
6	Parametrizzare pagina Analytics esistente	Frontend
7	Aggiornamento routing	Frontend
8	Testing & Validazione	QA
FASE 1: Schema Database
Obiettivo: Creare tabella per salvare stato completo sessioni venditori umani, con stessa struttura usata per AI.

Passo 1.1 - Aggiungere tabella in shared/schema.ts
// Dopo humanSellerSessionMetrics (circa linea 4250)
export const humanSellerMeetingTraining = pgTable("human_seller_meeting_training", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  meetingId: varchar("meeting_id").references(() => videoMeetings.id, { onDelete: "cascade" }).notNull().unique(),
  sellerId: varchar("seller_id").references(() => humanSellers.id, { onDelete: "cascade" }).notNull(),
  
  // Phase tracking (identico a sales_conversation_training)
  currentPhase: text("current_phase"),
  currentPhaseIndex: integer("current_phase_index").default(0),
  phasesReached: jsonb("phases_reached").$type<string[]>().default(sql`'[]'::jsonb`),
  
  // Checkpoint tracking
  checkpointsCompleted: jsonb("checkpoints_completed").$type<Array<{
    checkpointId: string;
    status: "completed" | "pending";
    completedAt: string;
  }>>().default(sql`'[]'::jsonb`),
  
  // Validated items per checkpoint
  validatedCheckpointItems: jsonb("validated_checkpoint_items").$type<Record<string, Array<{
    check: string;
    status: "validated";
    infoCollected: string;
    evidenceQuote: string;
  }>>>().default(sql`'{}'::jsonb`),
  
  // Conversation messages
  conversationMessages: jsonb("conversation_messages").$type<Array<{
    role: "seller" | "prospect";
    content: string;
    timestamp: number;
    phase?: string;
  }>>().default(sql`'[]'::jsonb`),
  
  // Archetype state
  archetypeState: jsonb("archetype_state").$type<{
    detectedArchetype: string;
    confidence: number;
    traits: string[];
  } | null>(),
  
  // Full transcript (per replay)
  fullTranscript: jsonb("full_transcript").$type<Array<{
    speakerId: string;
    speakerName: string;
    text: string;
    timestamp: number;
    sentiment: "positive" | "neutral" | "negative";
  }>>().default(sql`'[]'::jsonb`),
  
  // Script snapshot (copia dello script usato)
  scriptSnapshot: jsonb("script_snapshot"),
  scriptVersion: text("script_version"),
  
  // Coaching metrics
  coachingMetrics: jsonb("coaching_metrics").$type<{
    totalBuySignals: number;
    totalObjections: number;
    objectionsHandled: number;
    scriptAdherenceScores: number[];
  }>(),
  
  // Metriche calcolate
  completionRate: real("completion_rate").default(0),
  totalDuration: integer("total_duration").default(0),
  
  // Timestamps
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

Passo 1.2 - Aggiungere type exports
export type HumanSellerMeetingTraining = typeof humanSellerMeetingTraining.$inferSelect;
export type InsertHumanSellerMeetingTraining = typeof humanSellerMeetingTraining.$inferInsert;

Passo 1.3 - Eseguire migrazione
npx drizzle-kit push

FASE 2: Funzioni Save/Load Stato Sessione
Obiettivo: Creare funzioni per persistere e recuperare stato dal DB

Passo 2.1 - Creare funzione saveSessionState() in server/websocket/video-ai-copilot.ts
// Aggiungere import
import { humanSellerMeetingTraining } from '@shared/schema';
// Variabile per debounce
const saveDebounceTimers = new Map<string, NodeJS.Timeout>();
const SAVE_DEBOUNCE_MS = 5000; // Max 1 salvataggio ogni 5 secondi
async function saveSessionState(session: SessionState): Promise<void> {
  const meetingId = session.meetingId;
  
  // Debounce: cancella timer precedente
  const existingTimer = saveDebounceTimers.get(meetingId);
  if (existingTimer) {
    clearTimeout(existingTimer);
  }
  
  // Imposta nuovo timer
  const timer = setTimeout(async () => {
    try {
      console.log(`üíæ [VideoCopilot] Saving session state for meeting ${meetingId}...`);
      
      await db
        .insert(humanSellerMeetingTraining)
        .values({
          meetingId: session.meetingId,
          sellerId: session.sellerId!,
          currentPhase: session.playbook?.phases?.[session.currentPhaseIndex]?.name || 'unknown',
          currentPhaseIndex: session.currentPhaseIndex,
          phasesReached: session.playbook?.phases?.slice(0, session.currentPhaseIndex + 1).map(p => p.name) || [],
          checkpointsCompleted: session.completedCheckpoints,
          validatedCheckpointItems: session.validatedCheckpointItems,
          conversationMessages: session.conversationMessages,
          archetypeState: session.archetypeState,
          fullTranscript: session.transcriptBuffer,
          scriptSnapshot: session.scriptStructure,
          coachingMetrics: session.coachingMetrics,
          completionRate: calculateCompletionRate(session),
          totalDuration: Math.floor((Date.now() - session.coachingMetrics.sessionStartTime) / 1000),
          updatedAt: new Date(),
        })
        .onConflictDoUpdate({
          target: humanSellerMeetingTraining.meetingId,
          set: {
            currentPhase: session.playbook?.phases?.[session.currentPhaseIndex]?.name || 'unknown',
            currentPhaseIndex: session.currentPhaseIndex,
            phasesReached: session.playbook?.phases?.slice(0, session.currentPhaseIndex + 1).map(p => p.name) || [],
            checkpointsCompleted: session.completedCheckpoints,
            validatedCheckpointItems: session.validatedCheckpointItems,
            conversationMessages: session.conversationMessages,
            archetypeState: session.archetypeState,
            fullTranscript: session.transcriptBuffer,
            coachingMetrics: session.coachingMetrics,
            completionRate: calculateCompletionRate(session),
            totalDuration: Math.floor((Date.now() - session.coachingMetrics.sessionStartTime) / 1000),
            updatedAt: new Date(),
          },
        });
      
      console.log(`‚úÖ [VideoCopilot] Session state saved for meeting ${meetingId}`);
    } catch (error: any) {
      console.error(`‚ùå [VideoCopilot] Failed to save session state:`, error.message);
    }
    
    saveDebounceTimers.delete(meetingId);
  }, SAVE_DEBOUNCE_MS);
  
  saveDebounceTimers.set(meetingId, timer);
}
function calculateCompletionRate(session: SessionState): number {
  if (!session.playbook?.phases?.length) return 0;
  const totalPhases = session.playbook.phases.length;
  const completedPhases = session.currentPhaseIndex + 1;
  return Math.round((completedPhases / totalPhases) * 100);
}

Passo 2.2 - Creare funzione loadSessionState()
async function loadSessionState(meetingId: string): Promise<HumanSellerMeetingTraining | null> {
  try {
    console.log(`üìÇ [VideoCopilot] Loading existing session state for meeting ${meetingId}...`);
    
    const [saved] = await db
      .select()
      .from(humanSellerMeetingTraining)
      .where(eq(humanSellerMeetingTraining.meetingId, meetingId))
      .limit(1);
    
    if (saved) {
      console.log(`‚úÖ [VideoCopilot] Found saved state: phase ${saved.currentPhaseIndex}, ${saved.checkpointsCompleted?.length || 0} checkpoints`);
      return saved;
    }
    
    console.log(`üì≠ [VideoCopilot] No saved state found for meeting ${meetingId}`);
    return null;
  } catch (error: any) {
    console.error(`‚ùå [VideoCopilot] Error loading session state:`, error.message);
    return null;
  }
}

FASE 3: Integrazione Salvataggio nei Punti Chiave
Obiettivo: Chiamare saveSessionState() ogni volta che cambia qualcosa di importante

Passo 3.1 - Dopo completamento checkpoint (circa linea 1628)
// ESISTENTE:
session.completedCheckpoints.push({
  checkpointId,
  status: 'completed',
  completedAt: new Date().toISOString()
});
// AGGIUNGERE:
await saveSessionState(session);

Passo 3.2 - Dopo validazione item (circa linea 1615-1620)
// ESISTENTE:
session.validatedCheckpointItems[checkpointId].push({
  check: item.check,
  status: 'validated',
  infoCollected: item.infoCollected,
  evidenceQuote: item.evidenceQuote,
});
// AGGIUNGERE dopo il forEach:
await saveSessionState(session);

Passo 3.3 - Dopo aggiunta transcript (nella funzione che gestisce trascrizioni)
// Dopo push a transcriptBuffer:
session.transcriptBuffer.push({...});
await saveSessionState(session);

Passo 3.4 - In handleEndSession() - salvataggio finale immediato
// Salvataggio finale senza debounce
const timer = saveDebounceTimers.get(session.meetingId);
if (timer) clearTimeout(timer);
await saveSessionStateFinal(session); // Versione senza debounce

FASE 4: Recovery Stato al Riconnessione
Obiettivo: Quando utente si riconnette, caricare stato salvato invece di inizializzare vuoto

Passo 4.1 - Modificare inizializzazione sessione (circa linea 2820-2840)
// PRIMA (codice esistente):
const session: SessionState = {
  meetingId,
  clientId,
  // ...
  completedCheckpoints: [],
  validatedCheckpointItems: {},
  archetypeState: null,
  conversationMessages: [],
  transcriptBuffer: [],
};
// DOPO (codice modificato):
// Carica stato esistente se presente
const savedState = await loadSessionState(meetingId);
const session: SessionState = {
  meetingId,
  clientId,
  // ...
  completedCheckpoints: savedState?.checkpointsCompleted || [],
  validatedCheckpointItems: savedState?.validatedCheckpointItems || {},
  archetypeState: savedState?.archetypeState || null,
  conversationMessages: savedState?.conversationMessages || [],
  transcriptBuffer: savedState?.fullTranscript || [],
  currentPhaseIndex: savedState?.currentPhaseIndex || 0,
  scriptStructure: savedState?.scriptSnapshot || null,
};
if (savedState) {
  console.log(`üîÑ [VideoCopilot] Restored session: phase ${savedState.currentPhaseIndex}, ${savedState.checkpointsCompleted?.length || 0} checkpoints`);
}

Passo 4.2 - Inviare stato recuperato al client
// Dopo connessione, inviare stato checkpoint al frontend
if (savedState && savedState.checkpointsCompleted?.length > 0) {
  sendMessage(ws, {
    type: 'checkpoint_status',
    data: {
      completedCheckpoints: savedState.checkpointsCompleted,
      validatedItems: savedState.validatedCheckpointItems,
      currentPhaseIndex: savedState.currentPhaseIndex,
      restored: true,
    },
    timestamp: Date.now(),
  });
}

FASE 5: API Endpoints Umani (Stesso Formato AI)
Obiettivo: Creare endpoints che ritornano dati nello STESSO formato degli AI agent

Passo 5.1 - Aggiungere in server/routes/human-sellers.ts
// GET /api/client/human-sellers/:sellerId/training/stats
router.get('/:sellerId/training/stats', async (req, res) => {
  const { sellerId } = req.params;
  const clientId = req.user?.id;
  
  const stats = await db
    .select({
      totalConversations: sql`COUNT(*)`,
      averageCompletionRate: sql`AVG(completion_rate)`,
      averageDuration: sql`AVG(total_duration)`,
    })
    .from(humanSellerMeetingTraining)
    .where(eq(humanSellerMeetingTraining.sellerId, sellerId));
  
  res.json({
    totalConversations: Number(stats[0]?.totalConversations) || 0,
    averageCompletionRate: Number(stats[0]?.averageCompletionRate) || 0,
    totalLadderActivations: 0, // Non applicabile per umani
    averageDuration: Number(stats[0]?.averageDuration) || 0,
  });
});
// GET /api/client/human-sellers/:sellerId/training/conversations
router.get('/:sellerId/training/conversations', async (req, res) => {
  const { sellerId } = req.params;
  
  const conversations = await db
    .select({
      id: humanSellerMeetingTraining.id,
      meetingId: humanSellerMeetingTraining.meetingId,
      prospectName: videoMeetings.prospectName,
      currentPhase: humanSellerMeetingTraining.currentPhase,
      completionRate: humanSellerMeetingTraining.completionRate,
      totalDuration: humanSellerMeetingTraining.totalDuration,
      createdAt: humanSellerMeetingTraining.createdAt,
    })
    .from(humanSellerMeetingTraining)
    .leftJoin(videoMeetings, eq(videoMeetings.id, humanSellerMeetingTraining.meetingId))
    .where(eq(humanSellerMeetingTraining.sellerId, sellerId))
    .orderBy(desc(humanSellerMeetingTraining.createdAt));
  
  // Formato identico a quello AI
  res.json(conversations.map(c => ({
    id: c.meetingId, // Usiamo meetingId come ID conversazione
    prospectName: c.prospectName,
    currentPhase: c.currentPhase,
    completionRate: c.completionRate || 0,
    totalDuration: c.totalDuration || 0,
    ladderActivationCount: 0,
    createdAt: c.createdAt,
    usedScriptId: null,
    usedScriptName: null,
    usedScriptType: null,
    usedScriptSource: null,
  })));
});
// GET /api/client/human-sellers/:sellerId/training/conversation/:conversationId
router.get('/:sellerId/training/conversation/:conversationId', async (req, res) => {
  const { sellerId, conversationId } = req.params;
  
  const [detail] = await db
    .select()
    .from(humanSellerMeetingTraining)
    .where(and(
      eq(humanSellerMeetingTraining.sellerId, sellerId),
      eq(humanSellerMeetingTraining.meetingId, conversationId)
    ))
    .limit(1);
  
  if (!detail) {
    return res.status(404).json({ error: 'Conversation not found' });
  }
  
  // Formato identico a TrainingConversationDetail per AI
  res.json({
    conversationId: detail.meetingId,
    agentId: detail.sellerId,
    prospectName: null, // Da recuperare da videoMeetings se serve
    currentPhase: detail.currentPhase,
    phasesReached: detail.phasesReached || [],
    checkpointsCompleted: detail.checkpointsCompleted || [],
    semanticTypes: [],
    aiReasoning: [], // Non applicabile per umani (o da implementare)
    fullTranscript: (detail.fullTranscript || []).map(t => ({
      role: t.speakerId === 'host' ? 'assistant' : 'user',
      content: t.text,
      timestamp: new Date(t.timestamp).toISOString(),
      phase: detail.currentPhase || 'unknown',
    })),
    ladderActivations: [],
    questionsAsked: [],
    completionRate: detail.completionRate || 0,
    totalDuration: detail.totalDuration || 0,
    createdAt: detail.createdAt?.toISOString(),
    scriptSnapshot: detail.scriptSnapshot,
    scriptVersion: detail.scriptVersion,
  });
});

FASE 6: Parametrizzare Pagina Analytics Esistente
Obiettivo: Modificare client-sales-agent-analytics.tsx per supportare entrambi i tipi

Passo 6.1 - Aggiungere prop entityType e logica dinamica
// In client-sales-agent-analytics.tsx
interface Props {
  entityType?: 'ai_agent' | 'human_seller';
}
export default function ClientSalesAgentAnalytics({ entityType = 'ai_agent' }: Props) {
  const { agentId } = useParams<{ agentId: string }>();
  const entityId = agentId; // Funziona per entrambi
  
  // API base path dinamico
  const apiBasePath = entityType === 'human_seller' 
    ? `/api/client/human-sellers/${entityId}`
    : `/api/client/sales-agent/config/${entityId}`;
  
  // Query stats
  const { data: trainingStats } = useQuery<TrainingStats>({
    queryKey: [`${apiBasePath}/training/stats`],
    queryFn: async () => {
      const response = await fetch(`${apiBasePath}/training/stats`, {
        headers: getAuthHeaders(),
      });
      if (!response.ok) throw new Error('Failed to fetch stats');
      return response.json();
    },
    enabled: !!entityId,
  });
  
  // Query conversations
  const { data: trainingConversations = [] } = useQuery<TrainingConversation[]>({
    queryKey: [`${apiBasePath}/training/conversations`],
    queryFn: async () => {
      const response = await fetch(`${apiBasePath}/training/conversations`, {
        headers: getAuthHeaders(),
      });
      if (!response.ok) throw new Error('Failed to fetch conversations');
      return response.json();
    },
    enabled: !!entityId,
  });
  
  // Stessa logica per conversation detail...
  
  // Icona e label dinamiche
  const EntityIcon = entityType === 'human_seller' ? User : Bot;
  const entityLabel = entityType === 'human_seller' ? 'Venditore' : 'AI Agent';
  const backPath = entityType === 'human_seller' 
    ? '/client/human-sellers' 
    : '/client/sales-agents';

Passo 6.2 - Modificare header e label
// Nel JSX, sostituire:
<Bot className="h-5 w-5" />
// Con:
<EntityIcon className="h-5 w-5" />
// Sostituire:
"Sales Agents"
// Con:
entityType === 'human_seller' ? 'Venditori' : 'Sales Agents'

FASE 7: Aggiornamento Routing
Obiettivo: Far puntare route umani allo stesso componente

Passo 7.1 - Modificare client/src/App.tsx
// ESISTENTE:
<Route path="/client/human-sellers/:sellerId/analytics">
  <ClientHumanSellerAnalytics />
</Route>
// MODIFICARE IN:
<Route path="/client/human-sellers/:sellerId/analytics">
  {(params) => <ClientSalesAgentAnalytics entityType="human_seller" />}
</Route>
// Oppure creare wrapper component:
function HumanSellerAnalyticsWrapper() {
  return <ClientSalesAgentAnalytics entityType="human_seller" />;
}

Passo 7.2 - Gestire parametro URL
// Nel componente, gestire entrambi i nomi parametro
const { agentId, sellerId } = useParams<{ agentId?: string; sellerId?: string }>();
const entityId = agentId || sellerId;

FASE 8: Testing & Validazione
Passo 8.1 - Test persistenza DB
1. Avviare meet venditore umano
2. Completare 2-3 checkpoint (pallini verdi)
3. Chiudere tab browser
4. Riaprire meet
5. ‚úÖ Verificare che checkpoint siano ancora verdi
6. ‚úÖ Verificare che transcript sia recuperato

Passo 8.2 - Test pagina Analytics umani
1. Completare almeno 1 sessione completa
2. Andare su /client/human-sellers/:sellerId/analytics
3. ‚úÖ Verificare tab "Panoramica" con stats
4. ‚úÖ Verificare tab "Addestramento" con lista conversazioni
5. ‚úÖ Cliccare "Dettagli" su una conversazione
6. ‚úÖ Verificare Training Map con fasi/checkpoint

Passo 8.3 - Test comparazione AI vs Umani
1. Aprire analytics di un AI agent
2. Aprire analytics di un venditore umano
3. ‚úÖ Stessa struttura UI
4. ‚úÖ Stessi tab disponibili
5. ‚úÖ Training Map funzionante per entrambi

üìÅ RIEPILOGO FILE DA MODIFICARE
File	Modifiche
shared/schema.ts	+ tabella human_seller_meeting_training
server/websocket/video-ai-copilot.ts	+ saveSessionState(), loadSessionState(), chiamate salvataggio, recovery init
server/routes/human-sellers.ts	+ 3 API endpoints training
client/src/pages/client-sales-agent-analytics.tsx	+ prop entityType, query dinamiche, label dinamiche
client/src/App.tsx	Modifica route umani ‚Üí stesso componente
‚è±Ô∏è STIMA TEMPO
Fase	Tempo stimato
Fase 1 (DB)	30 min
Fase 2-3 (Save/Load)	1.5 ore
Fase 4 (Recovery)	30 min
Fase 5 (API)	1 ora
Fase 6-7 (Frontend)	1 ora
Fase 8 (Test)	30 min
TOTALE	~5 ore
