import { logger } from './logger.js';
// @ts-ignore
import pkg from 'wave-resampler';
const { resample: waveResample } = pkg;
const log = logger.child('AUDIO');
const MULAW_BIAS = 33;
const MULAW_MAX = 32635;
const mulawDecodeTable = new Int16Array(256);
const mulawEncodeTable = new Uint8Array(65536);
function initMulawTables(): void {
    for (let i = 0; i < 256; i++) {
        let mulaw = ~i;
        const sign = mulaw & 0x80;
        const exponent = (mulaw >> 4) & 0x07;
        const mantissa = mulaw & 0x0f;
        let sample = ((mantissa << 3) + MULAW_BIAS) << exponent;
        sample -= MULAW_BIAS;
        if (sign) sample = -sample;
        mulawDecodeTable[i] = sample;
    }
    for (let i = -32768; i < 32768; i++) {
        const sign = i < 0 ? 0x80 : 0;
        let sample = Math.abs(i);
        if (sample > MULAW_MAX) sample = MULAW_MAX;
        sample += MULAW_BIAS;
        let exponent = 7;
        for (let expMask = 0x4000; (sample & expMask) === 0 && exponent > 0; exponent--, expMask >>= 1) { }
        const mantissa = (sample >> (exponent + 3)) & 0x0f;
        const mulaw = ~(sign | (exponent << 4) | mantissa);
        mulawEncodeTable[(i + 32768) & 0xffff] = mulaw & 0xff;
    }
    log.debug('Î¼-law lookup tables initialized');
}
initMulawTables();
export function mulawToPcm(mulawData: Buffer): Buffer {
    const pcmData = Buffer.alloc(mulawData.length * 2);
    for (let i = 0; i < mulawData.length; i++) {
        const sample = mulawDecodeTable[mulawData[i]];
        pcmData.writeInt16LE(sample, i * 2);
    }
    return pcmData;
}
export function pcmToMulaw(pcmData: Buffer): Buffer {
    const mulawData = Buffer.alloc(pcmData.length / 2);
    for (let i = 0; i < mulawData.length; i++) {
        const sample = pcmData.readInt16LE(i * 2);
        mulawData[i] = mulawEncodeTable[(sample + 32768) & 0xffff];
    }
    return mulawData;
}
// Resampling con wave-resampler (JavaScript puro, no dipendenze native)
export function resample(input: Buffer, inputRate: number, outputRate: number): Buffer {
    if (inputRate === outputRate) return input;

    try {
        // Converti Buffer Int16 in Float64Array normalizzato [-1, 1]
        const samples = new Float64Array(input.length / 2);
        for (let i = 0; i < samples.length; i++) {
            samples[i] = input.readInt16LE(i * 2) / 32768.0;
        }

        // Resample usando wave-resampler
        const resampled = waveResample(samples, inputRate, outputRate);

        // Converti Float64Array in Buffer Int16
        const output = Buffer.alloc(resampled.length * 2);
        for (let i = 0; i < resampled.length; i++) {
            const sample = Math.max(-1, Math.min(1, resampled[i]));
            output.writeInt16LE(Math.round(sample * 32767), i * 2);
        }

        return output;
    } catch (err) {
        log.error('Resample error, returning original', { error: err });
        return input;
    }
}
export function convertForGemini(fsAudio: Buffer, codec: string, inputRate: number = 16000): Buffer {
    let pcm: Buffer;
    if (codec === 'PCMU') {
        pcm = mulawToPcm(fsAudio);
    } else {
        pcm = fsAudio;
    }
    if (inputRate !== 16000) {
        pcm = resample(pcm, inputRate, 16000);
    }
    return pcm;
}
export function convertFromGemini(geminiAudio: Buffer, codec: string, outputRate: number = 16000): Buffer {
    let pcm = geminiAudio;
    // 1. Gemini manda a 24kHz, convertiamo a outputRate
    if (outputRate !== 24000) {
        pcm = resample(pcm, 24000, outputRate);
    }
    // 2. Se L16, ritorna PCM puro
    if (codec === 'L16') {
        return pcm;
    }
    // 3. Conversione PCMU se serve
    return pcmToMulaw(pcm);
}
export function pcmToBase64(pcmData: Buffer): string { return pcmData.toString('base64'); }
export function base64ToPcm(base64Data: string): Buffer { return Buffer.from(base64Data, 'base64'); }
log.info('Audio converter initialized with wave-resampler');