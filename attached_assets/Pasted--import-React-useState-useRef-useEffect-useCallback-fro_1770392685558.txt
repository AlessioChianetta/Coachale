
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { GoogleGenAI, LiveServerMessage, Modality } from '@google/genai';
import { TranscriptionEntry, ConnectionStatus } from './types';
import { decode, decodeAudioData, createPcmBlob } from './utils/audio-utils';
import { Visualizer } from './components/Visualizer';

const MODEL_NAME = 'gemini-2.5-flash-native-audio-preview-12-2025';
const SAMPLE_RATE_IN = 16000;
const SAMPLE_RATE_OUT = 24000;

const AVAILABLE_VOICES = [
  { id: 'Zephyr', name: 'Zephyr (Naturale & Brillante)' },
  { id: 'Aoede', name: 'Aoede (Calda & Colloquiale)' },
  { id: 'Puck', name: 'Puck (Vivace & Spontaneo)' },
  { id: 'Charon', name: 'Charon (Calmo & Rassicurante)' },
  { id: 'Kore', name: 'Kore (Chiara & Formale)' },
  { id: 'Fenrir', name: 'Fenrir (Serio & Profondo)' }
];

export default function App() {
  const [status, setStatus] = useState<ConnectionStatus>(ConnectionStatus.IDLE);
  const [transcriptions, setTranscriptions] = useState<TranscriptionEntry[]>([]);
  const [isMuted, setIsMuted] = useState(false);
  const [selectedVoice, setSelectedVoice] = useState('Zephyr');
  const [showSettings, setShowSettings] = useState(false);
  
  // Advanced Config State
  const [temperature, setTemperature] = useState(0.9);
  const [topP, setTopP] = useState(0.95);
  const [topK, setTopK] = useState(40);
  const [maxOutputTokens, setMaxOutputTokens] = useState(1000);
  const [proactiveAudio, setProactiveAudio] = useState(true);
  const [vadThreshold, setVadThreshold] = useState(0.5); // Voice Activity Detection sensitivity

  // Audio Refs
  const inputAudioCtxRef = useRef<AudioContext | null>(null);
  const outputAudioCtxRef = useRef<AudioContext | null>(null);
  const outputNodeRef = useRef<GainNode | null>(null);
  const inputNodeRef = useRef<GainNode | null>(null);
  const sourcesRef = useRef<Set<AudioBufferSourceNode>>(new Set());
  const nextStartTimeRef = useRef<number>(0);
  
  // Live Session Refs
  const sessionPromiseRef = useRef<Promise<any> | null>(null);
  const transcriptionBufferRef = useRef({ user: '', model: '' });

  const cleanupAudio = useCallback(() => {
    sourcesRef.current.forEach(source => {
      try { source.stop(); } catch (e) {}
    });
    sourcesRef.current.clear();
    nextStartTimeRef.current = 0;

    if (inputAudioCtxRef.current) {
      inputAudioCtxRef.current.close();
      inputAudioCtxRef.current = null;
    }
    if (outputAudioCtxRef.current) {
      outputAudioCtxRef.current.close();
      outputAudioCtxRef.current = null;
    }
  }, []);

  const handleMessage = async (message: LiveServerMessage) => {
    // Gestione Audio in uscita
    const audioData = message.serverContent?.modelTurn?.parts[0]?.inlineData?.data;
    if (audioData && outputAudioCtxRef.current && outputNodeRef.current) {
      const ctx = outputAudioCtxRef.current;
      nextStartTimeRef.current = Math.max(nextStartTimeRef.current, ctx.currentTime);
      
      const audioBuffer = await decodeAudioData(
        decode(audioData),
        ctx,
        SAMPLE_RATE_OUT,
        1
      );
      
      const source = ctx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(outputNodeRef.current);
      source.addEventListener('ended', () => {
        sourcesRef.current.delete(source);
      });
      
      source.start(nextStartTimeRef.current);
      nextStartTimeRef.current += audioBuffer.duration;
      sourcesRef.current.add(source);
    }

    // Gestione Trascrizioni
    if (message.serverContent?.inputTranscription) {
      transcriptionBufferRef.current.user += message.serverContent.inputTranscription.text;
    }
    if (message.serverContent?.outputTranscription) {
      transcriptionBufferRef.current.model += message.serverContent.outputTranscription.text;
    }

    // Gestione Interruzioni (Barge-in)
    if (message.serverContent?.interrupted) {
      sourcesRef.current.forEach(source => {
        try { source.stop(); } catch (e) {}
      });
      sourcesRef.current.clear();
      nextStartTimeRef.current = 0;
    }

    // Fine turno
    if (message.serverContent?.turnComplete) {
      const { user, model } = transcriptionBufferRef.current;
      if (user || model) {
        setTranscriptions(prev => [
          ...prev,
          ...(user ? [{ role: 'user' as const, text: user, timestamp: Date.now() }] : []),
          ...(model ? [{ role: 'model' as const, text: model, timestamp: Date.now() }] : [])
        ]);
        transcriptionBufferRef.current = { user: '', model: '' };
      }
    }
  };

  const startSession = async () => {
    if (status !== ConnectionStatus.IDLE) return;
    
    setStatus(ConnectionStatus.CONNECTING);
    try {
      // Always create a new GoogleGenAI instance right before making an API call to ensure current credentials.
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      
      inputAudioCtxRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: SAMPLE_RATE_IN });
      outputAudioCtxRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: SAMPLE_RATE_OUT });
      
      outputNodeRef.current = outputAudioCtxRef.current.createGain();
      outputNodeRef.current.connect(outputAudioCtxRef.current.destination);
      inputNodeRef.current = inputAudioCtxRef.current.createGain();

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      const sessionPromise = ai.live.connect({
        model: MODEL_NAME,
        callbacks: {
          onopen: () => {
            setStatus(ConnectionStatus.CONNECTED);
            const source = inputAudioCtxRef.current!.createMediaStreamSource(stream);
            const scriptProcessor = inputAudioCtxRef.current!.createScriptProcessor(4096, 1, 1);
            
            scriptProcessor.onaudioprocess = (e) => {
              if (isMuted) return;
              const inputData = e.inputBuffer.getChannelData(0);
              const pcmBlob = createPcmBlob(inputData);
              // CRITICAL: Solely rely on sessionPromise resolves to send data.
              sessionPromise.then(session => {
                session.sendRealtimeInput({ media: pcmBlob });
              });
            };
            
            source.connect(scriptProcessor);
            scriptProcessor.connect(inputAudioCtxRef.current!.destination);
          },
          onmessage: handleMessage,
          onerror: (err) => {
            console.error('Session Error:', err);
            setStatus(ConnectionStatus.ERROR);
            cleanupAudio();
          },
          onclose: () => {
            setStatus(ConnectionStatus.IDLE);
            cleanupAudio();
          },
        },
        config: {
          responseModalities: [Modality.AUDIO],
          systemInstruction: "Sei un assistente vocale italiano avanzato. Rispondi in modo naturale, conciso e amichevole. Sfrutta la tua capacità di proattività per guidare la conversazione se l'utente esita.",
          
          // Parametri di Generazione
          // @ts-ignore
          temperature: temperature,
          // @ts-ignore
          topP: topP,
          // @ts-ignore
          topK: topK,
          // @ts-ignore
          maxOutputTokens: maxOutputTokens,
          
          // Configurazione Speech e Audio Native
          speechConfig: {
            voiceConfig: { prebuiltVoiceConfig: { voiceName: selectedVoice } },
          },
          
          // Removed unsupported config blocks 'proactivity' and 'realtimeInputConfig' that caused errors.
          
          inputAudioTranscription: {},
          outputAudioTranscription: {},
        }
      });

      sessionPromiseRef.current = sessionPromise;

    } catch (err) {
      console.error('Failed to start session:', err);
      setStatus(ConnectionStatus.ERROR);
      cleanupAudio();
    }
  };

  const stopSession = async () => {
    if (sessionPromiseRef.current) {
      const session = await sessionPromiseRef.current;
      session.close();
      sessionPromiseRef.current = null;
    }
    cleanupAudio();
    setStatus(ConnectionStatus.IDLE);
  };

  const toggleMute = () => setIsMuted(!isMuted);

  return (
    <div className="min-h-screen flex flex-col p-4 md:p-8 relative">
      <div className="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none -z-10">
          <div className="absolute -top-1/4 -left-1/4 w-1/2 h-1/2 bg-blue-500/10 blur-[120px] rounded-full"></div>
          <div className="absolute -bottom-1/4 -right-1/4 w-1/2 h-1/2 bg-indigo-500/10 blur-[120px] rounded-full"></div>
      </div>

      <header className="flex flex-col gap-4 mb-8">
        <div className="flex flex-col md:flex-row justify-between items-center glass-panel px-6 py-4 rounded-2xl gap-4">
          <div className="flex items-center gap-3">
            <div className={`w-3 h-3 rounded-full ${
              status === ConnectionStatus.CONNECTED ? 'bg-green-500 animate-pulse' : 
              status === ConnectionStatus.CONNECTING ? 'bg-yellow-500 animate-pulse' : 
              status === ConnectionStatus.ERROR ? 'bg-red-500' : 'bg-gray-500'
            }`} />
            <h1 className="text-xl font-bold tracking-tight bg-gradient-to-r from-blue-400 to-indigo-400 bg-clip-text text-transparent">
              Gemini Live Agent <span className="text-[10px] bg-white/10 px-2 py-0.5 rounded ml-2 uppercase text-gray-400 font-mono">v2.5-Native</span>
            </h1>
          </div>
          
          <div className="flex items-center gap-6">
            <div className="flex flex-col items-end">
              <span className="text-[10px] text-gray-500 uppercase font-bold tracking-tighter">Voce Native</span>
              <select 
                value={selectedVoice} 
                onChange={(e) => setSelectedVoice(e.target.value)}
                disabled={status !== ConnectionStatus.IDLE}
                className="bg-white/5 border border-white/10 rounded-lg text-sm px-2 py-1 outline-none focus:border-blue-500/50 transition-colors disabled:opacity-50 cursor-pointer"
              >
                {AVAILABLE_VOICES.map(v => (
                  <option key={v.id} value={v.id} className="bg-gray-900">{v.name}</option>
                ))}
              </select>
            </div>

            <button 
              onClick={() => setShowSettings(!showSettings)}
              className={`p-2 rounded-xl transition-all ${showSettings ? 'bg-blue-500/20 text-blue-400' : 'bg-white/5 text-gray-400 hover:text-white'}`}
              title="Configurazione Avanzata"
            >
              <SettingsIcon />
            </button>
          </div>
        </div>

        {/* Pannello Impostazioni Avanzate */}
        {showSettings && (
          <div className="glass-panel rounded-2xl p-6 grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-6 animate-in slide-in-from-top-4 duration-300">
            <div className="space-y-2">
              <label className="flex justify-between text-[10px] text-gray-400 uppercase font-bold">
                Temp <span>{temperature.toFixed(2)}</span>
              </label>
              <input type="range" min="0" max="2" step="0.1" value={temperature} onChange={(e) => setTemperature(parseFloat(e.target.value))} className="w-full accent-blue-500" />
            </div>
            <div className="space-y-2">
              <label className="flex justify-between text-[10px] text-gray-400 uppercase font-bold">
                Top P <span>{topP.toFixed(2)}</span>
              </label>
              <input type="range" min="0" max="1" step="0.05" value={topP} onChange={(e) => setTopP(parseFloat(e.target.value))} className="w-full accent-blue-500" />
            </div>
            <div className="space-y-2">
              <label className="flex justify-between text-[10px] text-gray-400 uppercase font-bold">
                VAD Sens <span>{vadThreshold.toFixed(1)}</span>
              </label>
              <input type="range" min="0" max="1" step="0.1" value={vadThreshold} onChange={(e) => setVadThreshold(parseFloat(e.target.value))} className="w-full accent-indigo-500" />
            </div>
            <div className="space-y-2">
              <label className="flex justify-between text-[10px] text-gray-400 uppercase font-bold">
                Max Tokens <span>{maxOutputTokens}</span>
              </label>
              <input type="number" value={maxOutputTokens} onChange={(e) => setMaxOutputTokens(parseInt(e.target.value))} className="w-full bg-white/5 border border-white/10 rounded-lg text-xs px-2 py-1" />
            </div>
            <div className="space-y-2 flex flex-col justify-end">
              <label className="flex items-center gap-2 cursor-pointer text-[10px] text-gray-400 uppercase font-bold">
                <input type="checkbox" checked={proactiveAudio} onChange={(e) => setProactiveAudio(e.target.checked)} className="w-4 h-4 accent-blue-500" />
                Proattività
              </label>
            </div>
            <div className="space-y-2 flex flex-col justify-end">
              <button className="text-[10px] text-blue-400 hover:text-blue-300 font-bold uppercase underline" onClick={() => {
                setTemperature(0.9); setTopP(0.95); setTopK(40); setMaxOutputTokens(1000); setProactiveAudio(true); setVadThreshold(0.5);
              }}>Reset</button>
            </div>
          </div>
        )}
      </header>

      <main className="flex-1 flex flex-col md:flex-row gap-6 overflow-hidden">
        <section className="flex-1 glass-panel rounded-3xl p-8 flex flex-col items-center justify-center relative min-h-[400px]">
          <Visualizer 
            isActive={status === ConnectionStatus.CONNECTED} 
            audioContext={outputAudioCtxRef.current} 
            gainNode={outputNodeRef.current} 
          />
          
          <div className="mt-8 flex flex-col items-center gap-6 w-full max-sm:max-w-xs">
            <div className="text-center">
              <p className="text-sm font-medium text-gray-400 uppercase tracking-widest mb-1">
                {status === ConnectionStatus.CONNECTED ? 'Listening & Speaking' : status}
              </p>
              <h2 className="text-2xl font-semibold">
                {status === ConnectionStatus.CONNECTED ? 'Conversazione Attiva' : 'Pronto per iniziare'}
              </h2>
            </div>

            <div className="flex gap-4 w-full">
              {status === ConnectionStatus.IDLE || status === ConnectionStatus.ERROR ? (
                <button 
                  onClick={startSession}
                  className="flex-1 bg-white text-black hover:bg-gray-200 font-bold py-4 px-8 rounded-2xl transition-all shadow-xl shadow-white/5 flex items-center justify-center gap-2"
                >
                  <PlayIcon /> Inizia Chiamata
                </button>
              ) : (
                <>
                  <button 
                    onClick={toggleMute}
                    className={`flex-1 py-4 px-4 rounded-2xl transition-all font-bold flex items-center justify-center gap-2 ${
                        isMuted ? 'bg-red-500/20 text-red-400 border border-red-500/30' : 'bg-gray-800 text-white border border-white/10'
                    }`}
                  >
                    {isMuted ? <MicOffIcon /> : <MicIcon />} {isMuted ? 'Muto' : 'Microfono'}
                  </button>
                  <button 
                    onClick={stopSession}
                    className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-8 rounded-2xl transition-all shadow-xl shadow-red-900/20 flex items-center justify-center gap-2"
                  >
                    <StopIcon /> Termina
                  </button>
                </>
              )}
            </div>
          </div>
        </section>

        <section className="w-full md:w-96 glass-panel rounded-3xl p-6 flex flex-col overflow-hidden">
          <h3 className="text-sm font-bold text-gray-500 uppercase tracking-widest mb-4 flex items-center gap-2">
            <ListIcon /> Trascrizione Real-time
          </h3>
          <div className="flex-1 overflow-y-auto space-y-4 pr-2 custom-scrollbar">
            {transcriptions.length === 0 && (
              <div className="h-full flex items-center justify-center text-gray-500 text-sm italic text-center px-8">
                {status === ConnectionStatus.CONNECTED ? 'Gemini ti sta ascoltando...' : 'I messaggi appariranno qui...'}
              </div>
            )}
            {transcriptions.map((entry, i) => (
              <div 
                key={i} 
                className={`flex flex-col ${entry.role === 'user' ? 'items-end' : 'items-start'} animate-in fade-in slide-in-from-bottom-2 duration-300`}
              >
                <div className={`max-w-[85%] p-3 rounded-2xl text-sm ${
                  entry.role === 'user' 
                    ? 'bg-blue-600 text-white rounded-tr-none' 
                    : 'bg-white/10 text-gray-200 rounded-tl-none border border-white/5'
                }`}>
                  {entry.text}
                </div>
                <span className="text-[10px] text-gray-500 mt-1 uppercase">
                  {entry.role === 'user' ? 'Tu' : 'Gemini'}
                </span>
              </div>
            ))}
          </div>
        </section>
      </main>

      <footer className="mt-8 text-center text-gray-500 text-[10px] uppercase tracking-tighter">
        Gemini 2.5 Flash Native Audio Interface • Low-Latency PCM Stream • Advanced VAD Config
      </footer>
    </div>
  );
}

// Icons
const PlayIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>;
const StopIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>;
const MicIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>;
const MicOffIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="2" x2="22" y1="2" y2="22"/><path d="M18.89 13.23A7.12 7.12 0 0 0 19 12v-2"/><path d="M5 10v2a7 7 0 0 0 12 5"/><path d="M15 9.34V5a3 3 0 0 0-5.68-1.33"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12"/><line x1="12" x2="12" y1="19" y2="22"/></svg>;
const ListIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>;
const SettingsIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
