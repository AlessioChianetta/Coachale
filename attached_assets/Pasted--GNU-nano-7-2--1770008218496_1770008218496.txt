  GNU nano 7.2                                                                                                                                                                                                                                                                                                                                                                                                   /opt/alessia-voice/vps-voice-bridge/src/audio-converter.ts                                                                                                                                                                                                                                                                                                                                                                                                             
import { logger } from './logger.js';
// @ts-ignore
import SpeexResampler from 'speex-resampler';

const log = logger.child('AUDIO');

const MULAW_BIAS = 33;
const MULAW_MAX = 32635;
const mulawDecodeTable = new Int16Array(256);
const mulawEncodeTable = new Uint8Array(65536);

function initMulawTables(): void {
    for (let i = 0; i < 256; i++) {
        let mulaw = ~i;
        const sign = mulaw & 0x80;
        const exponent = (mulaw >> 4) & 0x07;
        const mantissa = mulaw & 0x0f;
        let sample = ((mantissa << 3) + MULAW_BIAS) << exponent;
        sample -= MULAW_BIAS;
        if (sign) sample = -sample;
        mulawDecodeTable[i] = sample;
    }
    for (let i = -32768; i < 32768; i++) {
        const sign = i < 0 ? 0x80 : 0;
        let sample = Math.abs(i);
        if (sample > MULAW_MAX) sample = MULAW_MAX;
        sample += MULAW_BIAS;
        let exponent = 7;
        for (let expMask = 0x4000; (sample & expMask) === 0 && exponent > 0; exponent--, expMask >>= 1) { }
        const mantissa = (sample >> (exponent + 3)) & 0x0f;
        const mulaw = ~(sign | (exponent << 4) | mantissa);
        mulawEncodeTable[(i + 32768) & 0xffff] = mulaw & 0xff;
    }
    log.debug('μ-law lookup tables initialized');
}
initMulawTables();

export function mulawToPcm(mulawData: Buffer): Buffer {
    const pcmData = Buffer.alloc(mulawData.length * 2);
    for (let i = 0; i < mulawData.length; i++) {
        const sample = mulawDecodeTable[mulawData[i]];
        pcmData.writeInt16LE(sample, i * 2);
    }
    return pcmData;
}

export function pcmToMulaw(pcmData: Buffer): Buffer {
    const mulawData = Buffer.alloc(pcmData.length / 2);
    for (let i = 0; i < mulawData.length; i++) {
        const sample = pcmData.readInt16LE(i * 2);
        mulawData[i] = mulawEncodeTable[(sample + 32768) & 0xffff];
    }
    return mulawData;
}

// Funzione statica per usi occasionali
export function resample(input: Buffer, inputRate: number, outputRate: number): Buffer {
    if (inputRate === outputRate) return input;
    try {
        const resampler = new (SpeexResampler as any)(1, inputRate, outputRate, 10); // Qualità 10
        return resampler.process(input);
    } catch (err) {
        return input; // Fail safe
    }
}

export function convertForGemini(fsAudio: Buffer, codec: string, inputRate: number = 16000): Buffer {
    let pcm: Buffer;
    if (codec === 'PCMU') {
        pcm = mulawToPcm(fsAudio);
    } else {
        pcm = fsAudio;
    }
    // Per l'upload (verso Gemini) il resample statico va bene, è meno critico
    if (inputRate !== 16000) {
        pcm = resample(pcm, inputRate, 16000);
    }
    return pcm;
}

// *** MODIFICATA: Accetta un resamplerInstance opzionale ***
export function convertFromGemini(
    geminiAudio: Buffer,
    codec: string,
    outputRate: number = 16000,
    resamplerInstance?: any // <--- QUI LA MAGIA
): Buffer {
    let pcm = geminiAudio;

    // 1. Resampling da 24k a outputRate
    if (outputRate !== 24000) {
        if (resamplerInstance) {
            // USA IL RESAMPLER PERSISTENTE (Nessun buco audio!)
            try {
                pcm = resamplerInstance.process(pcm);
            } catch (e) {
                log.error('Resampler error', { error: e });
                pcm = resample(pcm, 24000, outputRate);
            }
        } else {
            // Fallback (crea e distruggi - causa glitch)
            pcm = resample(pcm, 24000, outputRate);
        }
    }

    // 2. Se L16, ritorna PCM puro
    if (codec === 'L16') {
        return pcm;
    }

    // 3. Conversione PCMU se serve
    return pcmToMulaw(pcm);
}

export function pcmToBase64(pcmData: Buffer): string { return pcmData.toString('base64'); }
export function base64ToPcm(base64Data: string): Buffer { return Buffer.from(base64Data, 'base64'); }