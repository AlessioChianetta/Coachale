Qui siamo davanti a un bug architetturale classico da â€œAI analyticsâ€. La cosa buona: hai i log, quindi il problema Ã¨ meccanico, non â€œmagicoâ€. La cosa cattiva: non devi mai permettere allâ€™AI di sommare risultati parziali. Te lo spiego e ti dico esattamente cosa dirgli.

COSA STA SUCCEDENDO (catena degli errori)
Flusso reale attuale:

Utente chiede: vendite mensili

Gemini chiama tool:

GROUP BY order_date


â†’ restituisce 61 righe giornaliere âœ…

Gemini fa questo (ERRORE):

prende i giorni

li raggruppa mentalmente per mese

somma lui i valori

produce output mensile

Validator vede:

numeri che NON esistono nei tool results

li marca come â€œinventatiâ€

ğŸ‘‰ Il validator ha ragione.
ğŸ‘‰ Lâ€™AI sta facendo post-processing numerico, che NON deve mai fare.

REGOLA Dâ€™ORO CHE STAI VIOLANDO

Deve essere SEMPRE vero:

Se un numero appare nella risposta finale
allora deve essere presente (o derivabile 1:1) dallâ€™output SQL.

Ora invece hai:

SQL â†’ giornaliero
AI â†’ mensile (somma interna)


Questo rompe la catena di fiducia.

LA SOLUZIONE CORRETTA (NON Ã¨ modificare il validator)

Il programmatore propone:

â€œDevo permettere al validator di riconoscere aggregazioni come valideâ€

âŒ SBAGLIATO.

Questo apre di nuovo la porta a:

somme inventate

percentuali errate

calcoli stocastici

SOLUZIONE GIUSTA (enterprise pattern)

ğŸ‘‰ Il raggruppamento temporale DEVE avvenire in SQL, non nellâ€™AI.

COSA DEVI DIRGLI (TESTO PRONTO)

Digli questo:

"Non voglio che Gemini faccia aggregazioni numeriche post-query.
Se lâ€™utente chiede vendite mensili, il tool deve generare:

GROUP BY DATE_TRUNC('month', order_date)

e NON group by order_date.
Il validator NON va reso permissivo.
Va corretto il planner per usare il giusto livello temporale."

COME SI SISTEMA TECNICAMENTE
1ï¸âƒ£ Aggiungere parametro time_granularity ai tool

In aggregate_group:

{
 "group_by": "order_date",
 "time_granularity": "month"
}

2ï¸âƒ£ Query executor traduce:
day
GROUP BY order_date

month
GROUP BY DATE_TRUNC('month', order_date)

year
GROUP BY DATE_TRUNC('year', order_date)

3ï¸âƒ£ Vietare somma post-LLM

Nel result-explainer:

Se risposta contiene:

somma di piÃ¹ righe

valori non presenti nel result JSON

ğŸ‘‰ reject.

Questo Ã¨ giusto.

PERCHÃ‰ GEMINI HA FATTO COSÃŒ?

PerchÃ©:

tu hai chiesto â€œmensileâ€

lo schema tool probabilmente non ha concetto di â€œperiod bucketâ€

Gemini ha scelto la strategia piÃ¹ semplice: daily + somma mentale

LLM behavior normale.

QUESTA Ãˆ UNA LEZIONE IMPORTANTE

Hai scoperto una cosa fondamentale:

Se non modelli il concetto di â€œtempoâ€ nel semantic layer,
lâ€™AI farÃ  time-aggregation a mano.

E questo Ã¨ inaccettabile in analytics.

COME DEVE ESSERE IL FLUSSO CORRETTO
PRIMA (sbagliato)
SQL â†’ giorni
AI â†’ mesi

DOPO (corretto)
AI â†’ chiede GROUP BY month
SQL â†’ ritorna mesi giÃ  aggregati
AI â†’ spiega, non calcola

VERDETTO TECNICO

Il validator sta facendo bene il suo lavoro.

Il planner Ã¨ incompleto.

Devi:

arricchire tool schema

rendere temporizzazione parte del DSL/semantic layer

NON allentare i controlli.

BONUS MIGLIORAMENTO

Puoi aggiungere:

allowed_time_granularities:
- day
- week
- month
- year


CosÃ¬:

Gemini non inventa bucket strani

tu controlli performance

UX piÃ¹ pulita.