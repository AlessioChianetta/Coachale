function formatCompactFeedback(params: CompactFeedbackParams): string {
  // ðŸ”§ FIX: Feedback UNIFICATO - evita duplicazioni e ripetizioni!
  
  const parts: string[] = [];
  const seenContent = new Set<string>(); // Track giÃ  visti per evitare duplicati
  
  // Helper per aggiungere solo se non duplicato
  const addUnique = (content: string) => {
    const normalized = content.toLowerCase().trim();
    if (normalized.length > 5 && !seenContent.has(normalized)) {
      seenContent.add(normalized);
      parts.push(content);
    }
  };
  
  // 1. OBIETTIVO della fase corrente (PRIMA DI TUTTO - questo Ã¨ il piÃ¹ importante!)
  if (params.currentObjective && params.currentObjective.length > 5) {
    addUnique(`ðŸŽ¯ OBIETTIVO: ${params.currentObjective}`);
  }
  
  // ðŸ†• 1.5. AI INTUITION E SUGGERIMENTO AI (dal checkpoint)
  if (params.aiIntuition && params.aiIntuition.length > 0) {
    addUnique(`ðŸ§  AI INTUITION: ${params.aiIntuition}`);
  }
  if (params.aiSuggestion && params.aiSuggestion.length > 0) {
    addUnique(`ðŸ’¡ AI SUGGESTION: ${params.aiSuggestion}`);
  }
  
  // 2. TONO dall'archetipo (usa toneReminder se presente, altrimenti archetypeState)
  // Questo previene duplicazioni tra toneReminder e archetypeNote
  if (params.toneReminder && params.toneReminder.length > 5) {
    // Se toneReminder Ã¨ giÃ  presente, usalo direttamente (viene dal SalesManager)
    const cleanTone = params.toneReminder
      .replace(/Tono:\s*/gi, '')
      .replace(/Adatta il tuo stile a/gi, '')
      .trim();
    if (cleanTone.length > 5) {
      addUnique(cleanTone);
    }
  } else {
    // Altrimenti usa l'archetypeState come fallback
    const archetypeNote = getArchetypeNote(params.archetypeState);
    if (archetypeNote) {
      addUnique(archetypeNote);
    }
  }
  
  // 3. INFO MANCANTI (solo se non ci sono altri feedback piÃ¹ importanti)
  if (params.checkpointItemDetails && params.checkpointItemDetails.length > 0 && parts.length === 0) {
    const missingChecks = params.checkpointItemDetails
      .filter(item => item.status !== 'validated')
      .slice(0, 2); // MAX 2 check per volta per evitare sovraccarico
    
    missingChecks.forEach(item => {
      let actionToShow = '';
      
      if (item.suggestedNextAction) {
        actionToShow = item.suggestedNextAction
          .replace(/^Chiedi:\s*/i, '')
          .replace(/^Domanda:\s*/i, '')
          .replace(/^['"]/, '')
          .trim();
      }
      
      if (!actionToShow || actionToShow.length < 5) {
        actionToShow = item.check;
      }
      
      if (actionToShow && actionToShow.length > 5) {
        addUnique(actionToShow);
      }
    });
  }
  
  // 4. FALLBACK: Se ancora vuoto, usa needsImprovement ripulito
  if (parts.length === 0 && params.needsImprovement && params.needsImprovement.length > 10) {
    const cleaned = params.needsImprovement
      .replace(/ðŸŽ¯\s*PROSSIMI\s*PASSI:?\s*/gi, '')
      .replace(/â†’\s*/g, '')
      .replace(/\bstep\b/gi, '')
      .replace(/\bfase\b/gi, '')
      .replace(/\bcheckpoint\b/gi, '')
      .trim();
    if (cleaned.length > 10) {
      addUnique(cleaned);
    }
  }
  
  // Unisci tutto in singola riga (massimo 2 frasi per evitare overload)
  let feedback = parts.slice(0, 2).join('. ');
  if (feedback && !feedback.endsWith('.')) feedback += '.';
  
  // ULTIMATE FALLBACK
  if (!feedback || feedback.length < 10) {
    feedback = 'Continua la conversazione in modo naturale.';
  }
  
  console.log(`   ðŸ“Š [COMPACT FEEDBACK] Generato (${feedback.length} chars, ${parts.length} parts)`);
  
  return feedback;
}

function getStrengthFromParams(params: CompactFeedbackParams): string {
  const { doingWell, feedbackType } = params;
  
  if (doingWell.includes('rapport') || doingWell.includes('relazione')) {
    return 'Buon rapport costruito';
  }
  if (doingWell.includes('tono') || doingWell.includes('Tono')) {
    return 'Conversazione fluida';
  }
  if (feedbackType === 'buy_signal') {
    return 'Segnali positivi rilevati';
  }
  if (doingWell.length > 0 && doingWell !== 'Stai seguendo lo script') {
    return doingWell.substring(0, 50);
  }
  return 'Stai procedendo bene';
}

function getWeaknessFromParams(params: CompactFeedbackParams): string {
  const { needsImprovement, feedbackType, feedbackPriority } = params;
  
  if (feedbackType === 'control_loss') {
    return 'riprendi controllo con domanda mirata';
  }
  if (feedbackType === 'out_of_scope') {
    return 'guida verso i servizi che offri';
  }
  if (params.toneAnalysis?.consecutiveQuestions && params.toneAnalysis.consecutiveQuestions > 2) {
    return 'troppe domande consecutive, aspetta risposta';
  }
  if (feedbackPriority === 'critical' || feedbackPriority === 'high') {
    // Estrai azione dal needsImprovement
    const action = needsImprovement.split('\n')[0]
      .replace(/^[âš ï¸ðŸŽ¯â†’â—â€¢]\s*/g, '')
      .substring(0, 60);
    if (action.length > 10) return action;
  }
  if (needsImprovement.includes('approfond')) {
    return 'approfondisci prima di procedere';
  }
  return '';
}