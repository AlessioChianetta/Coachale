root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# cat replit-ws-client.ts 
import { WebSocket } from 'ws';
import { config } from './config.js';
import { logger } from './logger.js';
import { base64ToPcm, pcmToBase64 } from './audio-converter.js';

const log = logger.child('REPLIT-WS');

export interface ReplitClientOptions {
  sessionId: string;
  callerId: string;
scheduledCallId?: string;
  mode?: string;
  voice?: string;
  onAudioResponse: (audioData: Buffer) => void;
  onTextResponse?: (text: string) => void;
  onError: (error: Error) => void;
  onClose: () => void;
}

export class ReplitWSClient {
  private ws: WebSocket | null = null;
  private sessionId: string;
  private callerId: string;
private scheduledCallId?: string;
  private options: ReplitClientOptions;
  private isConnected = false;
  private audioSequence = 0;

  constructor(options: ReplitClientOptions) {
    this.sessionId = options.sessionId;
    this.callerId = options.callerId;

this.scheduledCallId = options.scheduledCallId; 
    this.options = options;
  }

  async connect(): Promise<void> {
    const mode = this.options.mode || 'phone_service';
    const voice = this.options.voice || config.voice.voiceId;

    let wsUrl = `${config.replit.wsUrl}?token=${config.replit.apiToken}&mode=${mode}&useFullPrompt=false&voice=${voice}&source=phone&callerId=${encodeURIComponent(this.callerId)}`;

if (this.scheduledCallId) {
    wsUrl += `&scheduledCallId=${encodeURIComponent(this.scheduledCallId)}`;
  }

    log.info(`Connecting to Replit WebSocket`, {
      sessionId: this.sessionId.slice(0, 8),
      url: config.replit.wsUrl,
      voice,
    });

    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(wsUrl);

      const connectionTimeout = setTimeout(() => {
        if (!this.isConnected) {
          this.ws?.close();
          reject(new Error('Replit WebSocket connection timeout'));
        }
      }, 15000);

      this.ws.on('open', () => {
        log.info(`Replit WebSocket connected`, { sessionId: this.sessionId.slice(0, 8) });
        this.isConnected = true;
        clearTimeout(connectionTimeout);
        resolve();
      });

      this.ws.on('message', (data: any, isBinary: boolean) => {
        // Gestione messaggi in arrivo
        this.handleMessage(data);
      });

      this.ws.on('error', (error) => {
        log.error(`Replit WebSocket error`, {
          sessionId: this.sessionId.slice(0, 8),
          error: error.message,
        });
        clearTimeout(connectionTimeout);
        this.options.onError(error);
        if (!this.isConnected) {
          reject(error);
        }
      });

      this.ws.on('close', (code, reason) => {
        log.info(`Replit WebSocket closed`, {
          sessionId: this.sessionId.slice(0, 8),
          code,
          reason: reason.toString(),
        });
        this.isConnected = false;
        this.options.onClose();
      });
    });
  }

  private handleMessage(data: any): void {
    try {
      const text = data.toString();
      const message = JSON.parse(text);

      // *** FIX CRITICO: Accettiamo sia 'audio' che 'audio_output' ***
      if ((message.type === 'audio' || message.type === 'audio_output') && message.data) {
        // Convertiamo l'audio base64 in PCM e lo mandiamo a FreeSWITCH
        const audioData = base64ToPcm(message.data);
        this.options.onAudioResponse(audioData);
      }

      // Gestione del testo e transcript per debug
      if ((message.type === 'text' || message.type === 'ai_transcript') && (message.text || message.message)) {
        const txt = message.text || message.message;
        log.info(`[AI DICE]: ${txt}`);
        this.options.onTextResponse?.(txt);
      }

      if (message.type === 'error') {
        log.error(`[REPLIT ERROR]: ${message.error || message.message}`);
      }

    } catch (error) {
      // Fallback per audio binario puro (se mai dovesse arrivare)
      if (Buffer.isBuffer(data) && data.length > 0) {
        try {
          this.options.onAudioResponse(data);
        } catch (e) {
          log.error(`Error handling binary message`, { error: e instanceof Error ? e.message : 'Unknown' });
        }
      }
    }
  }

  sendAudio(pcmData: Buffer): void {
    if (!this.isConnected || !this.ws) return;

    const message = {
      type: 'audio',
      data: pcmToBase64(pcmData),
      sequence: this.audioSequence++,
    };
    this.send(message);
  }

  sendText(text: string): void {
    if (!this.isConnected || !this.ws) return;
    const message = { type: 'text', text };
    this.send(message);
  }

  private send(message: object): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }

  close(): void {
    if (this.ws) {
      try {
        this.ws.close(1000, 'Session ended');
      } catch (e) {}
      this.ws = null;
    }
    this.isConnected = false;
  }
}
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# dir
audio-converter.ts  config.ts      index.ts   outbound-handler.ts  session-manager.ts
caller-context.ts   esl-client.ts  logger.ts  replit-ws-client.ts  voice-bridge-server.ts
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# cat voice-bridge-server.ts 
import { WebSocketServer, WebSocket } from 'ws';
import { createServer, type IncomingMessage } from 'http';
import express from 'express';
import { parse as parseUrl } from 'url';
import { config } from './config.js';
import { logger } from './logger.js';
import { sessionManager } from './session-manager.js';
import { ReplitWSClient } from './replit-ws-client.js';
import { convertForGemini, convertFromGemini } from './audio-converter.js';
import { fetchCallerContext, notifyCallStart, notifyCallEnd } from './caller-context.js';
import { callMetadata } from './esl-client.js';
import { handleOutboundCall } from './outbound-handler.js';

const log = logger.child('SERVER');

let pendingCallId: string | null = null;
let pendingCallTimer: NodeJS.Timeout | null = null;

export function setExpectedCallId(uuid: string): void {
  pendingCallId = uuid;
  log.info(`Expecting connection for Call ID: ${uuid}`);
  if (pendingCallTimer) clearTimeout(pendingCallTimer);
  pendingCallTimer = setTimeout(() => {
    if (pendingCallId === uuid) pendingCallId = null;
  }, 5000);
}

interface AudioStreamStartMessage {
  event: 'start';
  call_id: string;
  caller_id: string;
  called_number: string;
  codec: 'PCMU' | 'L16';
  sample_rate: number;
}

interface AudioStreamStopMessage {
  event: 'stop';
  call_id: string;
  reason: string;
}

type AudioStreamMessage = AudioStreamStartMessage | AudioStreamStopMessage;

function firstQueryValue(v: unknown): string {
  if (Array.isArray(v)) return typeof v[0] === 'string' ? v[0] : '';
  return typeof v === 'string' ? v : '';
}

// Valida il service token (ricevuto da Replit)
function validateServiceToken(token: string | undefined): boolean {
  if (!token) return false;
  const expectedToken = config.serviceToken || process.env.REPLIT_SERVICE_TOKEN;
  return token === expectedToken;
}

export function startVoiceBridgeServer(): void {
  const app = express();
  app.use(express.json());

  // =============================================
  // ENDPOINT OUTBOUND: Riceve richieste da Replit
  // =============================================
  app.post('/outbound/call', async (req, res) => {
    const authHeader = req.headers.authorization;
    const token = authHeader?.replace('Bearer ', '');

    if (!validateServiceToken(token)) {
      log.warn('Unauthorized outbound request');
      return res.status(401).json({ success: false, error: 'Unauthorized' });
    }

    const { targetPhone, callId, aiMode, customPrompt } = req.body;

    if (!targetPhone || !callId) {
      return res.status(400).json({ success: false, error: 'Missing targetPhone or callId' });
    }

    const result = await handleOutboundCall({ targetPhone, callId, aiMode, customPrompt });

    if (result.success) {
      res.json(result);
    } else {
      res.status(500).json(result);
    }
  });

  // Health check
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });

  const server = createServer(app);

  const wss = new WebSocketServer({ server });

  wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
    const clientIp = req.socket.remoteAddress || 'unknown';
    log.info(`New WebSocket connection`, { clientIp });

    let currentSessionId: string | null = null;
    let callId = pendingCallId;

log.info('ðŸ” PENDING CALL ID CHECK', { 
  pendingCallId, 
  hasPending: !!pendingCallId,
  timestamp: Date.now() 
});

    if (callId) {
      pendingCallId = null;
      if (pendingCallTimer) clearTimeout(pendingCallTimer);

      const metadata = callMetadata.get(callId);
      const callerId = metadata?.callerIdNumber || 'unknown';
      const callerName = metadata?.callerIdName || '';

      log.info(`ðŸ“ž Call detected: ID=${callId} | CallerId=${callerId} | CallerName=${callerName}`);

      const startMsg: AudioStreamStartMessage = {
        event: 'start',
        call_id: callId,
        caller_id: callerId,
        called_number: '9999',
        codec: 'L16',
        sample_rate: 16000,
      };

      handleCallStart(ws, startMsg).then((sid) => {
        currentSessionId = sid;
      }).catch((e) => {
        log.error(`Session init error: ${e.message}`);
        ws.close(1011, 'Session init failed');
      });
    }

    ws.on('message', (data: Buffer, isBinary: boolean) => {
      if (isBinary && currentSessionId) {
        handleAudioData(currentSessionId, data);
      }
    });

    ws.on('close', () => {
      if (currentSessionId) {
        log.info(`WebSocket closed (Session: ${currentSessionId})`);
        const session = sessionManager.getSession(currentSessionId);
        if (session) handleCallStop(session.callId, 'websocket_closed');
      }
    });
  });

  server.listen(config.ws.port, config.ws.host, () => {
    log.info(`Voice Bridge Server started on port ${config.ws.port}`);
    log.info(`Outbound endpoint ready at POST /outbound/call`);
  });
}

async function handleCallStart(ws: WebSocket, message: AudioStreamStartMessage): Promise<string> {
  const session = sessionManager.createSession(
    message.call_id, message.caller_id, message.called_number,
    message.codec, message.sample_rate, ws
  );

  await notifyCallStart(session.id, message.caller_id, message.called_number);

  const replitClient = new ReplitWSClient({
    sessionId: session.id,
    callerId: message.caller_id,
    scheduledCallId: message.call_id,
    onAudioResponse: (audio) => {
      sendAudioToFreeSWITCH(session.id, audio);
    },
    onTextResponse: (text) => {
      log.info(`[AI]: "${text}"`);
    },
    onError: (err) => {
      log.error(`Replit Error: ${err.message}`);
    },
    onClose: () => log.info(`Replit connection closed`),
  });

  await replitClient.connect();
  sessionManager.setReplitClient(session.id, replitClient);
  sessionManager.updateSessionState(session.id, 'active');

  return session.id;
}

function handleAudioData(sessionId: string, audioData: Buffer): void {
  const session = sessionManager.getSession(sessionId);
  if (!session || session.state !== 'active') return;

  const pcm = convertForGemini(audioData, session.codec, session.sampleRate);
  session.replitClient?.sendAudio(pcm);
}

// Funzione modificata: MIXER RIMOSSO
function sendAudioToFreeSWITCH(sessionId: string, audio: Buffer): void {
  const session = sessionManager.getSession(sessionId);
  if (!session?.fsWebSocket || session.fsWebSocket.readyState !== WebSocket.OPEN) {
    return;
  }

  // Conversione diretta dell'audio originale
  const fsAudio = convertFromGemini(audio, session.codec, session.sampleRate);

  const CHUNK_SIZE = 640;
  for (let i = 0; i < fsAudio.length; i += CHUNK_SIZE) {
    const chunk = fsAudio.slice(i, i + CHUNK_SIZE);
    session.fsWebSocket.send(chunk, { binary: true });
  }
}

function handleCallStop(callId: string, reason: string): void {
  const session = sessionManager.getSessionByCallId(callId);
  if (!session) return;

  const duration = Date.now() - session.startTime.getTime();
  notifyCallEnd(session.id, duration, session.audioStats.bytesIn, session.audioStats.bytesOut, reason);
  sessionManager.endSession(session.id, reason);
}
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# dir
audio-converter.ts  config.ts      index.ts   outbound-handler.ts  session-manager.ts
caller-context.ts   esl-client.ts  logger.ts  replit-ws-client.ts  voice-bridge-server.ts
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# cat esl-client.ts 
import { config } from './config.js';
import { logger } from './logger.js';
import { setExpectedCallId } from './voice-bridge-server.js';
import esl from 'modesl';

const log = logger.child('ESL');

// Mappa per memorizzare caller info per UUID
export const callMetadata = new Map<string, { callerIdNumber: string, callerIdName: string }>();

export function startESLController(): void {
  log.info(`Connecting to FreeSWITCH ESL at ${config.esl.host}:${config.esl.port}...`);

  const conn = new esl.Connection(config.esl.host, config.esl.port, config.esl.password, () => {
    log.info('âœ… Connected to FreeSWITCH Event Socket!');
    conn.subscribe(['CHANNEL_PARK', 'CHANNEL_HANGUP']);
  });

  conn.on('esl::event::CHANNEL_PARK::*', (event: any) => {
    const uuid = event.getHeader('Unique-ID');
    const dest = event.getHeader('Caller-Destination-Number');

    if (dest !== '9999') return;

    const callerIdNumber = event.getHeader('Caller-Caller-ID-Number') || 'unknown';
    const callerIdName = event.getHeader('Caller-Caller-ID-Name') || '';

    log.info(`ðŸ…¿ï¸  Detected call to 9999 (Parked)`, { uuid, callerIdNumber, callerIdName });

    // Salva metadata per questo UUID
    callMetadata.set(uuid, { callerIdNumber, callerIdName });
    
    // ðŸŽ¯ FIX: Per chiamate OUTBOUND, l'outbound-handler ha giÃ  impostato il callId corretto (sc_xxx)
    // Non sovrascrivere con l'UUID di FreeSWITCH
    if (!uuid.startsWith('outbound-')) {
      setExpectedCallId(uuid);
      log.info(`ðŸ“ž INBOUND call - setting expected call ID`, { uuid });
    } else {
      log.info(`ðŸ“ž OUTBOUND call - keeping existing scheduled call ID`, { uuid });
    }

    // 1. Configurazione Audio Base
    (conn as any).bgapi(`uuid_setvar ${uuid} STREAM_PLAYBACK true`);
    (conn as any).bgapi(`uuid_setvar ${uuid} STREAM_SAMPLE_RATE 16000`);
    (conn as any).bgapi(`uuid_setvar ${uuid} mod_audio_stream_bidirectional true`);

    // 2. JITTERBUFFER (Elimina il packet loss iniziale e i "salti" audio)
    (conn as any).bgapi(`uuid_setvar ${uuid} jitterbuffer_msec 60:120`);

    // 3. MUSICA DI SOTTOFONDO (Nativa FreeSWITCH - Zero Latenza)
    const bgFile = '/opt/sounds/background.wav';
    log.info(`ðŸŽµ Starting native background music`, { uuid });
    (conn as any).bgapi(`uuid_displace ${uuid} start '${bgFile}' 0 mux`);

    // 4. Connessione Stream AI
    const wsUrl = `ws://172.17.0.1:${config.ws.port}`;
    const streamCmd = `uuid_audio_stream ${uuid} start ${wsUrl} mono 16000`;

    log.debug(`ðŸš€ Executing stream command on PARKED call`, { cmd: streamCmd });

    (conn as any).bgapi(streamCmd, (res: any) => {
        const body = res.getBody();
        if (body && body.includes('+OK')) {
            log.info(`âœ… Audio stream initiated successfully`, { uuid });
        } else {
            log.error(`âŒ Failed to start audio stream`, { uuid, error: body || 'Unknown error' });
        }
    });
  });

  conn.on('esl::event::CHANNEL_HANGUP::*', (event: any) => {
    const uuid = event.getHeader('Unique-ID');
    const dest = event.getHeader('Caller-Destination-Number');
    if (dest === '9999') {
      log.debug(`ðŸ›‘ Call 9999 ended`, { uuid });
      callMetadata.delete(uuid);
    }
  });

  conn.on('error', (err: any) => {
    log.error('âŒ ESL Connection Error', { error: err?.message || err });
    setTimeout(() => startESLController(), 5000);
  });
}
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# dir
audio-converter.ts  config.ts      index.ts   outbound-handler.ts  session-manager.ts
caller-context.ts   esl-client.ts  logger.ts  replit-ws-client.ts  voice-bridge-server.ts
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# cat outbound-handler.ts 
import { logger } from './logger.js';
import { config } from './config.js';
import pkg from 'modesl';
const { Connection } = pkg;
import { setExpectedCallId } from './voice-bridge-server.js';

const log = logger.child('OUTBOUND');

interface OutboundCallRequest {
  targetPhone: string;
  callId: string;
  aiMode: string;
  customPrompt?: string;
}

interface OutboundCallResponse {
  success: boolean;
  callId?: string;
  freeswitchUuid?: string;
  error?: string;
}

function validatePhoneNumber(phone: string): boolean {
  const cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
  return /^(\+?[1-9]\d{6,14}|\d{3,6})$/.test(cleanPhone);
}

function normalizePhone(phone: string): string {
  let clean = phone.replace(/[\s\-\(\)]/g, '');
  if (clean.startsWith('00')) clean = '+' + clean.slice(2);
  return clean;
}

function isInternalExtension(phone: string): boolean {
  const clean = phone.replace(/[\s\-\(\)]/g, '');
  return /^\d{3,6}$/.test(clean) && !clean.startsWith('+');
}

async function originateCall(targetPhone: string, callId: string): Promise<{ uuid: string }> {
  return new Promise((resolve, reject) => {
    const conn = new Connection(
      config.esl?.host || '127.0.0.1',
      config.esl?.port || 8021,
      config.esl?.password || 'ClueCon'
    );

    conn.on('error', (err: Error) => {
      log.error('ESL connection error', { error: err.message });
      reject(new Error('ESL connection failed: ' + err.message));
    });

    conn.on('esl::ready', () => {
      const uuid = 'outbound-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);
      const normalizedPhone = normalizePhone(targetPhone);
      const callerId = config.sip?.callerId || '+390000000000';

      let dialString: string;
      if (isInternalExtension(normalizedPhone)) {
        dialString = 'user/' + normalizedPhone;
        log.info('Calling internal extension', { extension: normalizedPhone });
      } else {
        const gateway = config.sip?.gateway || 'voip_trunk';
        dialString = 'sofia/gateway/' + gateway + '/' + normalizedPhone;
        log.info('Calling external number via gateway', { phone: normalizedPhone, gateway });
      }

      // ðŸŽ¯ FIX: Imposta il callId di Replit come pending PRIMA dell'originate
      // CosÃ¬ quando FreeSWITCH si connette, il bridge sa che Ã¨ OUTBOUND
      setExpectedCallId(callId);
log.info('ðŸŽ¯ SET EXPECTED CALL ID', { callId, timestamp: Date.now() });


      const originateCmd = 'originate {origination_uuid=' + uuid + ',origination_caller_id_number=' + callerId + ',origination_caller_id_name=Alessia}' + dialString + ' &transfer(9999 XML default)';

      log.info('Executing originate command', { uuid, dialString });

      (conn as any).api(originateCmd, (result: any) => {
        const response = result?.body || '';
        log.info('Originate result', { response });

        if (response.includes('-ERR')) {
          reject(new Error('FreeSWITCH error: ' + response));
        } else {
          resolve({ uuid });
        }

        conn.disconnect();
      });
    });
  });
}

export async function handleOutboundCall(req: OutboundCallRequest): Promise<OutboundCallResponse> {
  const { targetPhone, callId, aiMode } = req;

  log.info('Received outbound call request', { callId, targetPhone, aiMode });

  if (!validatePhoneNumber(targetPhone)) {
    log.warn('Invalid phone number', { targetPhone });
    return { success: false, error: 'Invalid phone number format' };
  }

  if (!callId) {
    return { success: false, error: 'Missing callId' };
  }

  try {
    const result = await originateCall(targetPhone, callId);
    log.info('Call originated successfully', { callId, uuid: result.uuid });

    return {
      success: true,
      callId,
      freeswitchUuid: result.uuid,
    };
  } catch (error: any) {
    log.error('Failed to originate call', { callId, error: error.message });
    return {
      success: false,
      callId,
      error: error.message,
    };
  }
}
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# dir
audio-converter.ts  config.ts      index.ts   outbound-handler.ts  session-manager.ts
caller-context.ts   esl-client.ts  logger.ts  replit-ws-client.ts  voice-bridge-server.ts
root@srv1164256:/opt/alessia-voice/vps-voice-bridge/src# 