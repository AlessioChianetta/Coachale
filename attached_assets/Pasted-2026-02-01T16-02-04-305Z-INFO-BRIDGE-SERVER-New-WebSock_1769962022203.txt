2026-02-01T16:02:04.305Z [INFO ] [BRIDGE:SERVER] New WebSocket connection clientIp=127.0.0.1 root@srv1164256:/opt/alessia-voice/vps-voice-bridge# TOKEN=7a8fad4d5ad94fe3bc342c1c1799b5ea
curl -s "http://127.0.0.1:9090/stats?token=$TOKEN" | head -c 400; echo
{"stats":{"activeSessions":0,"maxSessions":10,"totalBytesIn":0,"totalBytesOut":0},"sessions":[]}
root@srv1164256:/opt/alessia-voice/vps-voice-bridge# 
Ragionato per 2m 18s

Perfetto: ora hai la prova che FreeSWITCH si connette al bridge (New WebSocket connection clientIp=127.0.0.1).
Il motivo per cui /stats resta a 0 sessioni √® nel tuo codice: una sessione viene creata solo quando arriva un messaggio JSON ‚Äústart‚Äù, ma mod_audio_stream di default non manda nessun JSON ‚Äústart/stop‚Äù. Lui apre la WS e poi streamma direttamente audio binario (L16); l‚Äôunico testo che pu√≤ mandare ‚Äúprima‚Äù √® il parametro metadata (opzionale).

Quindi adesso il problema non √® pi√π ‚Äúconnessione‚Äù, ma protocollo: il bridge sta aspettando un JSON che non arriver√†.

Cosa fare (la strada pi√π semplice e robusta)
‚úÖ Soluzione consigliata: passare i dati via query string e creare la sessione al connect

Gi√† sai che la query string funziona (/health?token=... OK). Quindi fai cos√¨:

Modifica il bridge: quando arriva una WS connection, leggi call_id, caller_id, ecc. dalla query e chiama handleCallStart() subito (senza aspettare un messaggio ‚Äústart‚Äù).

Modifica il comando FreeSWITCH: aggiungi quei parametri nell‚ÄôURL.

Risultato: appena FS apre la WS, il bridge crea subito la sessione ‚Üí /stats sale a 1 ‚Üí l‚Äôaudio binario viene processato.

1) Patch al bridge (2‚Äì3 minuti)

Nel tuo src/voice-bridge-server.ts, dentro:

wss.on('connection', (ws, req) => {
  ...


aggiungi dopo l‚Äôauth e dopo il check canAcceptNewCall() (prima di let currentSessionId...) questo blocco:

    // ---- AUTO-START SESSION FROM URL QUERY (mod_audio_stream sends binary audio, no "start" JSON) ----
    const q = url.query;

    const callId = typeof q.call_id === 'string' ? q.call_id : '';
    const callerId = typeof q.caller_id === 'string' ? q.caller_id : 'unknown';
    const calledNumber = typeof q.called_number === 'string' ? q.called_number : 'unknown';
    const sampleRate = typeof q.sample_rate === 'string' ? parseInt(q.sample_rate, 10) : 16000;
    const codecQ = typeof q.codec === 'string' ? q.codec : 'L16';

    let currentSessionId: string | null = null;

    // If query contains call_id, we can start immediately.
    if (callId) {
      const startMsg = {
        event: 'start',
        call_id: callId,
        caller_id: callerId,
        called_number: calledNumber,
        codec: (codecQ === 'PCMU' ? 'PCMU' : 'L16') as any,
        sample_rate: Number.isFinite(sampleRate) ? sampleRate : 16000,
      };

      // Start session immediately (so binary audio frames are not ignored)
      handleCallStart(ws, startMsg as any).then((sid) => {
        currentSessionId = sid;
      }).catch((e) => {
        log.error('Failed to start session from query', { error: e?.message || String(e) });
        ws.close(1011, 'Session init failed');
      });
    }


‚ö†Ô∏è Nota: sto usando as any per evitare che TypeScript ti blocchi se codec non √® esattamente nel union. Se vuoi farlo pulito, estendi il tipo codec o crea un tipo separato per ‚ÄústartMsg da query‚Äù.

Importantissimo: ora currentSessionId va dichiarato prima degli handler ws.on('message', ...) e poi usato normalmente.

üëâ In pratica devi spostare il tuo let currentSessionId: string | null = null; sopra, e non dichiararlo due volte. Quindi: elimina quello vecchio e tieni questo.

Poi build + restart:

cd /opt/alessia-voice/vps-voice-bridge
npm run build
systemctl restart alessia-voice
journalctl -u alessia-voice -f

2) Cambia il comando FreeSWITCH (quello che fai da fs_cli o dialplan)

Invece di:
ws://127.0.0.1:9090/?token=...

usa:
ws://127.0.0.1:9090/?token=...&call_id=...&caller_id=...&called_number=...&codec=L16&sample_rate=16000

Esempio manuale (sostituisci UUID reale):

UUID=a3adb7e3-ef0b-47ef-92c5-94dbf6470543
TOKEN=7a8fad4d5ad94fe3bc342c1c1799b5ea

docker exec -it freeswitch fs_cli -H 127.0.0.1 -P 8021 -p '1NoxIsTheBest1!' -x \
"uuid_audio_stream $UUID start ws://127.0.0.1:9090/?token=$TOKEN&call_id=$UUID&caller_id=1000&called_number=9999&codec=L16&sample_rate=16000 mono 16000"


mod_audio_stream streamma in L16.

3) Verifica: adesso /stats deve vedere 1 sessione

Subito dopo lo start:

TOKEN=7a8fad4d5ad94fe3bc342c1c1799b5ea
curl -s "http://127.0.0.1:9090/stats?token=$TOKEN"


Atteso: activeSessions: 1 + sessions: [...]

E nei log bridge dovresti vedere:

New WebSocket connection

Call started ...

poi (se Replit ok) Call active - Replit connected

Alternativa (se vuoi evitare i parametri in URL): usa ‚Äúmetadata‚Äù

Il modulo supporta metadata che viene inviato come testo prima dell‚Äôaudio.
Quindi potresti fare:

uuid_audio_stream <uuid> start <url> mono 16000 "<metadata>"

ma devi poi cambiare il bridge per trattare il primo messaggio testo come metadata (non come JSON start). √à un filo pi√π macchinoso per via dell‚Äôescaping in XML, quindi io ti consiglio la query string.

Perch√© ora vedi ‚ÄúWS connection‚Äù ma 0 sessioni

Perch√© il tuo bridge crea sessione solo qui:

if (message.event === 'start') {
  currentSessionId = await handleCallStart(ws, message);
}


Ma mod_audio_stream non manda quel JSON ‚Äústart‚Äù. Lui manda audio binario e (opzionale) metadata testuale.