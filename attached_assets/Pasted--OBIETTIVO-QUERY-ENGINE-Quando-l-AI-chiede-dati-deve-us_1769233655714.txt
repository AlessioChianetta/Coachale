ğŸ¯ OBIETTIVO QUERY ENGINE

Quando lâ€™AI chiede dati deve:

usare SEMPRE la colonna giusta

evitare filtri sbagliati

gestire fallback automatici

non fare calcoli matematicamente errati

non inventare logica business

âœ… LE 7 REGOLE CHE DEVI AGGIUNGERE AL MOTORE QUERY
1ï¸âƒ£ Regola PrioritÃ  Fatturato (CRITICA)
âŒ Errore attuale

A volte usi:

SUM(price * quantity)

âœ… Regola corretta

Nel resolver:

IF revenue_amount EXISTS:
    USE SUM(revenue_amount)
ELSE:
    USE SUM(price * quantity)

Impatto:

sconti corretti

resi corretti

fiscalmente coerente

2ï¸âƒ£ Filtro automatico document_type

Ogni query di fatturato/margine deve auto-iniettare:

WHERE document_type = 'sale'

Eccezione:

Solo se lâ€™utente chiede esplicitamente:

includi resi
includi void
mostra storni

Implementazione:
IF metric IN (revenue, gross_margin, food_cost)
AND no explicit document_type filter:
    inject document_type='sale'

3ï¸âƒ£ Regola canale vendite (sales_channel)

Se lâ€™utente NON specifica:

â¡ default:

sales_channel IN ('dine_in','takeaway','delivery')


Se specifica:

delivery
asporto
sala

â¡ filtra solo quello.

4ï¸âƒ£ Regola time_slot automatica

Se lâ€™utente chiede:

pranzo
cena
mattina
sera

Mapping automatico:
{
 "lunch": [11:00-15:00],
 "dinner": [18:00-23:00],
 "breakfast": [6:00-11:00],
 "late": [23:00-04:00]
}

Query engine:
IF time_slot column exists:
   filter time_slot
ELSE:
   filter EXTRACT(hour from order_date)


Questo elimina bug sul "conviene aprire a pranzo".

5ï¸âƒ£ Regola categoria SEMANTICA (importantissima)

Errore che hai visto:

category = 'Food'
product_name ILIKE '%pizza%'

Va eliminato.
Regola nuova:

Se lâ€™utente dice:

pizze
bevande
dessert

Devi:

PRIORITÃ€:
1) category semantic mapping
2) fallback ILIKE solo se category NON esiste

Implementazione:
IF category role exists:
    inject category='Pizza'
ELSE:
    use product_name ILIKE patterns

6ï¸âƒ£ Regola ORDER BY SEMANTICO

Errore che hai visto:

profittevoli
piÃ¹ redditizi

ma ha ordinato per quantity.

Regola:
Keyword AI	ORDER BY
profittevoli	gross_margin DESC
piÃ¹ venduti	quantity DESC
fatturato	revenue DESC
piÃ¹ cari	avg_unit_price DESC
meno profittevoli	gross_margin ASC
Hard override:
Semantic ORDER BY > LLM ORDER BY

7ï¸âƒ£ Regola sicurezza matematica (divisioni)

Ovunque fai:

food_cost_percent

gross_margin_percent

ticket_medio

Devi sempre usare:
NULLIF(denominatore,0)


Hai giÃ  iniziato bene.

ğŸš¦QUERY PIPELINE IDEALE

Quando arriva domanda AI:

1) Intent detect
2) Metric detect
3) Semantic category detect
4) Time_slot detect
5) Channel detect
6) Document_type inject
7) Revenue priority resolver
8) ORDER BY semantic override
9) SQL generate

ğŸ“Œ IN SINTESI: COSA AGGIUNGI NEL CODICE
Devi implementare SOLO questi moduli:

âœ… Revenue resolver
âœ… Document type auto-filter
âœ… Time slot resolver
âœ… Category semantic override
âœ… Order by semantic override
âœ… Safe division guard

ğŸ¯ Risultato

Con questi:

âœ” addio "zero risultati sbagliati"
âœ” addio pizza non trovata
âœ” addio fatturati inventati
âœ” AI diventa affidabile
âœ” puoi vendere enterprise