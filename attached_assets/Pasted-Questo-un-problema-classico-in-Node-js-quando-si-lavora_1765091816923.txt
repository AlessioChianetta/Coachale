Questo è un problema classico in Node.js quando si lavora con i WebSocket.Molto probabilmente l'errore si verifica perché entrambi i servizi stanno cercando di "ascoltare" (bind) lo stesso evento di upgrade o la stessa porta sullo stesso server HTTP, senza un meccanismo per distinguere quale richiesta vada a quale servizio.Ecco l'analisi del problema e come risolverlo.Il Problema: Conflitto sull'Evento "Upgrade"I WebSocket funzionano iniziando come una normale richiesta HTTP che poi viene "promossa" (upgrade) a connessione WebSocket.Quando passi server alle tue funzioni (setupGeminiLiveWSService(server), ecc.), è probabile che al loro interno ciascuna funzione stia facendo qualcosa del genere:JavaScript// All'interno delle tue funzioni di setup (Esempio di cosa NON fare più volte)
const wss = new WebSocket.Server({ server: server }); // <--- COLPEVOLE
Se lo fai due volte sullo stesso server, la seconda istanza tenterà di sovrascrivere o interferire con la gestione delle connessioni della prima, oppure lancerà un errore perché la porta/socket è già impegnata in quella modalità.ShutterstockLa Soluzione: Routing Manuale (Pattern noServer)Per far convivere più WebSocket sullo stesso server (stessa porta 3000, 8080, ecc.), devi agire come un vigile urbano. Devi intercettare la richiesta prima che entri nel WebSocket e smistarla in base all'URL (il percorso).Ecco i passaggi per risolvere:1. Modifica le funzioni di setup (Gemini e Video Copilot)Devi modificare il codice dentro setupGeminiLiveWSService e setupVideoCopilotWebSocket. Invece di passare server, crea il WebSocket in modalità "sganciata" (noServer: true) ed esporta l'istanza wss.Esempio di come modificare setupGeminiLiveWSService.js:JavaScript// Vecchio codice (probabilmente)
// const wss = new WebSocket.Server({ server });

// NUOVO CODICE
function setupGeminiLiveWSService() { // Nota: non serve passare 'server' qui
  const wss = new WebSocket.Server({ noServer: true }); // Importante!

  wss.on('connection', (ws) => {
    // ...tutta la tua logica esistente...
    console.log("Gemini Live connesso");
  });

  return wss; // Restituisci l'oggetto wss
}
Fai la stessa cosa per setupVideoCopilotWebSocket.2. Gestisci l'evento upgrade nel file principaleNel tuo file principale (dove hai const server = ...), devi gestire manualmente lo smistamento.JavaScriptconst url = require('url');

// 1. Inizializza i servizi WS (senza passare il server, vedi punto 1)
const wssGemini = setupGeminiLiveWSService();
const wssVideo = setupVideoCopilotWebSocket();

const server = await registerRoutes(app);

// 2. Gestisci l'upgrade manualmente
server.on('upgrade', (request, socket, head) => {
  const pathname = url.parse(request.url).pathname;

  if (pathname === '/gemini-ws') { // Definisci il percorso per Gemini
    wssGemini.handleUpgrade(request, socket, head, (ws) => {
      wssGemini.emit('connection', ws, request);
    });
  } 
  else if (pathname === '/video-copilot-ws') { // Definisci il percorso per Video AI
    wssVideo.handleUpgrade(request, socket, head, (ws) => {
      wssVideo.emit('connection', ws, request);
    });
  } 
  else {
    // Se il percorso non corrisponde a nessuno dei due, chiudi la connessione
    socket.destroy();
  }
});
Riassunto delle modificheCosaPrima (Errore)Dopo (Corretto)Creazione WSnew WebSocket.Server({ server })new WebSocket.Server({ noServer: true })Gestione EventoAutomatica (interna alla libreria)Manuale tramite server.on('upgrade', ...)RoutingNessuno (conflitto sulla root)Tramite pathname (/gemini vs /video)Alternativa veloce (se usi socket.io)Se uno dei due servizi usa socket.io e l'altro ws nativo, o entrambi socket.io, la gestione è diversa (si usano i "Namespaces"). Se usi la libreria standard ws (che è la più comune per Node), la soluzione sopra (noServer: true) è quella standard e più robusta.