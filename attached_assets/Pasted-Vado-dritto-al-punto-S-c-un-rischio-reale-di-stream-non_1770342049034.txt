Vado dritto al punto:
ğŸ‘‰ SÃ¬, câ€™Ã¨ un rischio reale di stream non chiusi correttamente.
Non Ã¨ disastroso, ma in certe condizioni puÃ² portare a 1011 / resource exhausted.

Adesso ti spiego esattamente cosa ho trovato.

ğŸ” 1ï¸âƒ£ Câ€™Ã¨ un registry delle connessioni?

SÃŒ âœ…

Hai:

activeGeminiConnections: Map<string, GeminiSession>


Ottimo. Questo Ã¨ fondamentale.

ğŸ”¥ 2ï¸âƒ£ Il problema potenziale

Il punto delicato Ã¨ questo:

Lo stream Gemini viene chiuso SOLO in questi casi:

onClose WebSocket

onError

kill-all endpoint

alcune parti di cleanup

âš ï¸ Ma non vedo una chiusura garantita e centralizzata nel momento in cui:

FreeSWITCH manda hangup

la chiamata termina lato voice bridge

la sessione passa a stato finale

In alcuni casi il codice si affida a eventi indiretti.

Questo puÃ² lasciare sessioni vive se:

il WebSocket non riceve close correttamente

lâ€™hangup non arriva come previsto

câ€™Ã¨ un errore silenzioso

ğŸ§  3ï¸âƒ£ Cosa succede quando una chiamata finisce?

Ho cercato:

handleCallStop

endSession

sessionManager.endSession

cleanup esplicito

Il cleanup esiste, ma non Ã¨ blindato in un finally globale.

Questo significa:

Se qualcosa va storto nel mezzo,
lo stream puÃ² restare aperto.

ğŸš¨ 4ï¸âƒ£ Mancano due protezioni fondamentali
âŒ Non vedo un MAX SESSION DURATION hard limit

Se una chiamata resta aperta troppo a lungo, non câ€™Ã¨ un kill automatico certo.

âŒ Non vedo un IDLE TIMEOUT forte

Se:

nessun audio

nessun messaggio

ma stream ancora aperto

Non câ€™Ã¨ un watchdog che lo chiude dopo X secondi.

ğŸ’£ 5ï¸âƒ£ PerchÃ© questo puÃ² causare 1011

Scenario realistico:

Fai 4â€“5 chiamate

1â€“2 sessioni non si chiudono

activeGeminiConnections cresce lentamente

Arrivi al limite concorrente del modello

Nuova sessione â†’ 1011 resource exhausted

Riavvio server â†’ tutto torna a zero â†’ sembra â€œmagiaâ€.

ğŸ¯ 6ï¸âƒ£ Cosa manca per essere a prova di bomba

Ti dico esattamente cosa aggiungerei.

âœ… Aggiungere MAX SESSION DURATION

Dentro la creazione sessione:

setTimeout(() => {
  if (activeGeminiConnections.has(sessionId)) {
    console.log("Force closing session (max duration)");
    session.close();
    activeGeminiConnections.delete(sessionId);
  }
}, 10 * 60 * 1000); // 10 minuti

âœ… Aggiungere IDLE WATCHDOG

Ogni volta che ricevi audio o testo:

session.lastActivity = Date.now();


E un interval globale:

setInterval(() => {
  for (const [id, session] of activeGeminiConnections) {
    if (Date.now() - session.lastActivity > 60000) {
      console.log("Closing idle Gemini session:", id);
      session.close();
      activeGeminiConnections.delete(id);
    }
  }
}, 30000);

âœ… Loggare sempre la size

Aggiungi:

setInterval(() => {
  console.log("ACTIVE GEMINI SESSIONS:", activeGeminiConnections.size);
}, 15000);


Se dopo chiusura chiamate non torna a 0 â†’ conferma leak.

ğŸ§  Verdetto finale

Non vedo un errore clamoroso tipo:

â€œmai chiusoâ€

Ma vedo che:

il lifecycle non Ã¨ blindato

manca un watchdog

manca un hard timeout

E questo Ã¨ sufficiente per spiegare il tuo 1011.