üìã Prompt Tecnico: Fix UX Chat, Race Conditions & Ottimizzazione
Ruolo: Senior Full-Stack Engineer & AI Specialist Contesto: Applicazione Chatbot Booking/Sales (Frontend React + Backend Node.js). Obiettivo: Risolvere bug critici di interfaccia, problemi di concorrenza (race conditions) e latenza.

Per favore risolvi i seguenti 5 punti critici:

1. üêõ Fix Doppi Messaggi (Ghosting UI)
Problema: Quando invio un messaggio, il frontend ne mostra momentaneamente due copie (vedi screenshot allegato):

Il messaggio "ottimistico" locale.

Il messaggio che ritorna dal socket/backend. Dopo un reload completo, ne rimane uno solo. Soluzione: Implementa una corretta deduplicazione dei messaggi basata su un tempId o timestamp. La UI deve riconciliare il messaggio locale con quello confermato dal server senza renderizzarli entrambi contemporaneamente.

2. üîí Logica di Blocco Input (UX)
Problema: L'input viene disabilitato solo durante isExtracting. Requisito: Estendi lo stato di blocco. L'utente NON deve poter scrivere/inviare messaggi:

Mentre isExtracting √® true.

E ANCHE mentre l'AI sta generando/scrivendo la risposta (isGenerating o isTyping).

Sblocca l'input solo quando il turno √® completato.

3. üôà Nascondere Messaggi di Sistema
Problema: Il messaggio di sistema "Extracting data..." appare come una nuvoletta nella chat, disturbando la conversazione. Requisito:

Mostra i log di estrazione solo nella console del browser o in una sidebar di debug.

NON renderizzarli mai come messaggi di chat nel flusso principale.

4. ‚è≥ Fix Conferma Asincrona (Race Condition Calendario)
Problema: L'AI risponde "Ho aggiornato il calendario" prima che la modifica sia effettivamente avvenuta o visibile nel widget (latenza backend > frontend). L'utente √® confuso perch√© legge la conferma ma non vede il cambiamento subito. Soluzione:

Rivedi la logica del BookingService o del Tool Call.

Assicurati che il messaggio di conferma ("Fatto, appuntamento spostato") venga inviato strettamente all'interno del blocco .then() o solo dopo che la await updateCalendar() ha restituito successo.

Se c'√® latenza di rete, mostra uno spinner di caricamento specifico sul widget del calendario.

5. ‚ö° Ottimizzazione Modello (Passaggio a Flash)
Obiettivo: Ridurre drasticamente la latenza del task Extracting data. Azione: Sostituisci il modello LLM usato per l'estrazione dati con Gemini 2.5 Flash lite. √à perfettamente capace di gestire estrazioni JSON ed √® significativamente pi√π veloce ed economico del modello attuale.