Valutazione rapida (onesta)
Cose buone âœ…

Hai separato intent â†’ tool â†’ risposta

Usi tool specifici (non mega-funzione)

Câ€™Ã¨ round-trip con output strutturato

Hai giÃ  orchestration a step

Problemi strutturali âŒ

Regex intent detection = collo di bottiglia

Forzare ANY mode Ã¨ pericoloso

Tools mescolano query + business logic

Mancano guardrail semantici

Flusso hard-coded

Ora andiamo punto per punto.

1ï¸âƒ£ Il tuo detectIntent Ã¨ il primo vero problema

Regex keyword matching Ã¨:

fragile linguistico

non multilingua

non semantico

rompe con parafrasi

Esempio che ti rompe:

"quanti incontri ho giÃ  portato a termine questo mese?"

Regex: âŒ
LLM intent classifier: âœ…

Soluzione corretta (Gemini-style)

Non usare regex.
Usa LLM intent classification leggera.

Pattern corretto:
User input
   â†“
LLM mini prompt:
"Classifica intent tra: consultations_status, booking, availability, other"
   â†“
Ricevi intent strutturato JSON

Output esempio:
{
  "intent": "consultations_status",
  "confidence": 0.93
}


ğŸ‘‰ Questo Ã¨ lo standard interno Google.

2ï¸âƒ£ Forzare mode ANY = errore architetturale

Tu stai dicendo:

"Gemini DEVE chiamare un tool"

Questo Ã¨ pericoloso.

PerchÃ©?

Se lâ€™utente chiede:

"cos'Ã¨ una consulenza?"

Gemini chiamerÃ  comunque un tool sbagliato.

Pattern sano:

Usa:

AUTO mode

Tool gating per intent

Pseudologica:
if intent == consultations_status:
   enable tools A
else:
   disable tools


MA lasci Gemini libero di:

rispondere senza tool

chiedere chiarimenti

3ï¸âƒ£ I tool che hai sono troppo â€œbusiness-mixedâ€

Attuali:

getConsultationStatus

getAvailableSlots

proposeBooking

confirmBooking

Problema:

Stai mescolando:

read operations

write operations

state transitions

Design piÃ¹ pulito (production)

Separazione per tipo:

READ
get_consultation_stats
get_calendar_availability

WRITE
create_booking_draft
confirm_booking
cancel_booking

STATE SAFE
validate_booking_request


Questo riduce errori LLM.

4ï¸âƒ£ Output tool: sei quasi giusto ma manca struttura semantica

Ora ritorni:

{completed: 2, scheduled: 1, totalUsed: 3}


Migliore versione:

{
  "status": "success",
  "period": "2026-01",
  "consultations": {
    "completed": 2,
    "scheduled": 1,
    "total": 3
  },
  "unit": "sessions"
}


ğŸ‘‰ CosÃ¬ Gemini:

capisce contesto temporale

puÃ² fare follow-up

non inventa unitÃ 

5ï¸âƒ£ Il round-trip Gemini â†’ tool â†’ Gemini va bene

Questo Ã¨ corretto ğŸ‘
Ma puoi migliorarlo:

Aggiungi "next_action_hint"
{
  "status": "success",
  "consultations": {...},
  "next_action_hint": "offer_booking"
}


Ora Gemini sa:

"Posso proporre nuova prenotazione?"

6ï¸âƒ£ Architettura target (come lo farei io)
Nuovo flusso:
Utente
  â†“
LLM intent classification (no tools)
  â†“
Router logico
  â†“
Attiva SOLO tool necessari
  â†“
Gemini AUTO tool use
  â†“
Tool returns structured result
  â†“
Gemini final response

7ï¸âƒ£ Bonus: come evitare ALLUCINAZIONI

Aggiungi sempre nel system prompt:

If data is missing, ask clarification before calling tools.

E lato backend:

rifiuta chiamate senza month/year

ritorna error_code

Versione "pro" del tuo caso specifico

Utente:

quante consulenze ho fatto questo mese?

Step 1 â€” Intent classifier
consultations_status

Step 2 â€” Tool call
get_consultation_stats {
  "period": "current_month"
}

Step 3 â€” Tool response
{
  "status": "success",
  "period": "2026-01",
  "consultations": {
    "completed": 2,
    "scheduled": 1
  }
}

Step 4 â€” Gemini response

Questo mese hai completato 2 consulenze e ne hai 1 programmata. Vuoi prenotarne unâ€™altra?

Verdetto finale

Il tuo sistema:

ğŸ‘‰ Ã¨ funzionante
ğŸ‘‰ NON Ã¨ scalabile
ğŸ‘‰ Ã¨ fragile linguisticamente
ğŸ‘‰ Ã¨ troppo hardcoded

Ma:

âœ” struttura giusta
âœ” sei sulla strada corretta
âœ” bastano 2â€“3 refactor mirati