  GNU nano 7.2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /opt/alessia-voice/vps-voice-bridge/src/voice-bridge-server.ts                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
        sample_rate: 16000,
      };

      handleCallStart(ws, startMsg).then((sid) => {
        currentSessionId = sid;
      }).catch((e) => {
        log.error(`Session init error: ${e.message}`);
        ws.close(1011, 'Session init failed');
      });
    }

    ws.on('message', (data: Buffer, isBinary: boolean) => {
      if (isBinary && currentSessionId) {
        handleAudioData(currentSessionId, data);
      }
    });

    ws.on('close', () => {
      if (currentSessionId) {
        log.info(`WebSocket closed (Session: ${currentSessionId})`);
        const session = sessionManager.getSession(currentSessionId);
        if (session) handleCallStop(session.callId, 'websocket_closed');
      }
    });
  });

  server.listen(config.ws.port, config.ws.host, () => {
    log.info(`Voice Bridge Server started on port ${config.ws.port}`);
    log.info(`Outbound endpoint ready at POST /outbound/call`);
  });
}

async function handleCallStart(ws: WebSocket, message: AudioStreamStartMessage): Promise<string> {
  const session = sessionManager.createSession(
    message.call_id, message.caller_id, message.called_number,
    message.codec, message.sample_rate, ws
  );

  await notifyCallStart(session.id, message.caller_id, message.called_number);

  const replitClient = new ReplitWSClient({
    sessionId: session.id,
    callerId: message.caller_id,
    onAudioResponse: (audio) => {
      sendAudioToFreeSWITCH(session.id, audio);
    },
    onTextResponse: (text) => {
      log.info(`[AI]: "${text}"`);
    },
    onError: (err) => {
      log.error(`Replit Error: ${err.message}`);
    },
    onClose: () => log.info(`Replit connection closed`),
  });

  await replitClient.connect();
  sessionManager.setReplitClient(session.id, replitClient);
  sessionManager.updateSessionState(session.id, 'active');

  return session.id;
}

function handleAudioData(sessionId: string, audioData: Buffer): void {
  const session = sessionManager.getSession(sessionId);
  if (!session || session.state !== 'active') return;

  const pcm = convertForGemini(audioData, session.codec, session.sampleRate);
  session.replitClient?.sendAudio(pcm);
}

function sendAudioToFreeSWITCH(sessionId: string, audio: Buffer): void {
  const session = sessionManager.getSession(sessionId);
  if (!session?.fsWebSocket || session.fsWebSocket.readyState !== WebSocket.OPEN) {
    return;
  }

  const fsAudio = convertFromGemini(audio, session.codec, session.sampleRate);

  const CHUNK_SIZE = 640;
  for (let i = 0; i < fsAudio.length; i += CHUNK_SIZE) {
    const chunk = fsAudio.slice(i, i + CHUNK_SIZE);
    session.fsWebSocket.send(chunk, { binary: true });
  }
}

function handleCallStop(callId: string, reason: string): void {
  const session = sessionManager.getSessionByCallId(callId);
  if (!session) return;

  const duration = Date.now() - session.startTime.getTime();
  notifyCallEnd(session.id, duration, session.audioStats.bytesIn, session.audioStats.bytesOut, reason);
  sessionManager.endSession(session.id, reason);
}
