Perfetto! Ti spiego la logica di quello che ho costruito:

Architettura del Sistema
1. Database (Backend)
sales_scripts table
â”œâ”€â”€ Salva i 3 tipi di script (discovery, demo, objections)
â”œâ”€â”€ Traccia versioni (v1.0.0, v1.1.0, ecc.)
â”œâ”€â”€ isActive = flag per dire quale script usa l'AI
â””â”€â”€ Possiede la struttura JSON con fasi, step, domande

2. API Backend (/api/sales-scripts)
GET â†’ Lista tutti i tuoi script
POST â†’ Crea nuovo script
PUT â†’ Modifica script e crea versione
POST /activate â†’ Attiva uno script (disattiva gli altri dello stesso tipo)
POST /seed-defaults â†’ Carica gli script base nel database
3. Script Cache (Ottimizzazione)
Prima volta che l'AI serve uno script â†’ lo carica dal DB e lo cachea
Se modifichi uno script â†’ la cache viene ripulita automaticamente
Questo riduce le query al database durante le conversazioni
4. AI Integration (Core Logic)
Quando uno dei tuoi agenti inizia una call:
1. Il WebSocket Gemini si connette
2. Carica il config dell'agente dal DB
3. **Chiama fetchClientScripts()** â†’ legge gli script ATTIVI dal DB
4. Se trova script personalizzati â†’ li usa
5. Se non trova nulla â†’ usa gli script hardcoded come fallback
6. Invia tutto a Gemini nel prompt

Cosa Testare (Step by Step)
Test 1: Carica Script di Default
Vai su /client/sales-agents/{agentId}/scripts
Clicca "Carica Script Base"
Dovresti vedere 3 script apparire (Discovery, Demo, Objections)
Test 2: Visualizza Struttura
Clicca su uno script (es. "Discovery Call - Base")
A sinistra: dovresti vedere le Fasi (Phase 1, 2, 3...) con step e domande
A destra: il contenuto testo completo dello script
Test 3: Modifica e Salva
Clicca "Modifica" in alto
Cambia qualcosa nel testo (es. una domanda)
Clicca "Salva" (aggiorna la versione attuale)
Oppure clicca "Salva Nuova Versione" (crea v1.1.0)
Test 4: Attiva uno Script
Crea un nuovo script o duplica uno esistente
Clicca "Attiva"
Vedrai che gli altri dello stesso tipo si disattivano
Importante: Quando l'AI fa una nuova call, userÃ  QUESTO script
Test 5: AI Usa il Nuovo Script
Una volta attivato uno script personalizzato
Avvia una nuova conversazione (una call con l'AI)
Nei logs del server dovresti vedere:
ğŸ“š [ScriptLoader] Fetching scripts from database...
ğŸ“š [ScriptLoader] Found 1 active scripts for client XXX

Questo significa che l'AI ha caricato il TUO script dal DB
Flusso Completo (Technical)
FRONTEND (Script Manager)
    â†“ (POST/PUT/DELETE)
API Routes (/api/sales-scripts)
    â†“ (salva nel DB)
Database (sales_scripts table)
    â†“ (legge quando serve)
AI (gemini-live-ws-service.ts)
    â†“ (chiama buildFullSalesAgentContextAsync)
prompt-builder.ts
    â†“ (chiama fetchClientScripts)
Script Cache â†’ se miss â†’ legge dal DB
    â†“
AI Prompt con gli script personalizzati
    â†“
Gemini risponde usando TUO script

Cosa Significa se Vedi Questi Log
âœ… Buono: ğŸ“š [ScriptLoader] Found 3 active scripts for client...

L'AI ha caricato i tuoi script dal database
âš ï¸ Fallback: â„¹ï¸ [ScriptLoader] No custom scripts found, using default scripts

Non hai script attivi nel DB, usa gli hardcoded
ğŸ”„ Cache: ğŸ—‘ï¸ [ScriptLoader] Cleared cache for client...

Hai modificato/attivato uno script, cache ripulita per usare quello nuovo



Ottima domanda! Ti spiego la struttura:

ğŸ¯ Architettura Corretta
Gli script sono a livello di CLIENTE (Account), non di singolo agente.

CLIENTE (es. "Marco Rossi - Entrepreneur")
â”‚
â”œâ”€â”€ Script Manager (condiviso)
â”‚   â”œâ”€â”€ Discovery Call v1.0 (ATTIVO)
â”‚   â”œâ”€â”€ Discovery Call v1.1 (non attivo)
â”‚   â”œâ”€â”€ Demo Call v1.0 (ATTIVO)
â”‚   â””â”€â”€ Objections v1.0 (ATTIVO)
â”‚
â””â”€â”€ Tutti gli Agenti del Cliente usano QUESTI script
    â”œâ”€â”€ Agent1: "Marco AI Sales Agent" â†’ usa Discovery v1.0, Demo v1.0, Objections v1.0
    â”œâ”€â”€ Agent2: "Marco Alternative Agent" â†’ usa gli STESSI script
    â””â”€â”€ Agent3: "Backup Agent" â†’ usa gli STESSI script

ğŸ“Œ Come Funziona
Scenario Pratico:

Tu crei 2 Sales Agent (entrambi tuoi, stesso cliente):

"Agent A" - per lead qualificati
"Agent B" - per follow-up
Carica script di default â†’ vanno in DB con clientId = tuo_id

Se modifichi il Discovery Script:

PUT /api/sales-scripts/{scriptId}
â†“
Script aggiornato in DB
â†“
Cache ripulita
â†“
TUTTI i tuoi agent usano subito il nuovo script

Se attivi una nuova versione:

"Salva Nuova Versione" (v1.0 â†’ v1.1)
Clicchi "Attiva"
Entrambi Agent A e Agent B usano v1.1
âš™ï¸ Flusso Tecnico
Agent A inizia call
    â†“ (WebSocket connect)
Legge: agentConfig.clientId = "client-123"
    â†“
fetchClientScripts("client-123")
    â†“
SELECT * FROM sales_scripts 
WHERE clientId = "client-123" AND isActive = true
    â†“
Trova: Discovery v1.0, Demo v1.0, Objections v1.0
    â†“
Agent A usa questi script

Agent B inizia call (stesso cliente)
    â†“ (WebSocket connect)
Legge: agentConfig.clientId = "client-123"
    â†“
fetchClientScripts("client-123")
    â†“
Trova: Discovery v1.0, Demo v1.0, Objections v1.0
    â†“
Agent B usa gli STESSI script

ğŸ”„ Implicazioni
âœ… Pro:

Un solo Script Manager per gestire tutti gli agent
Cambi uno script â†’ Ã¨ immediato per tutti
Versionamento centralizzato
Meno complessitÃ 
âŒ Se volessi script diversi per agent:

Dovremmo aggiungere agentId alla tabella sales_scripts
Ogni agent avrebbe script propri
PiÃ¹ complesso da gestire
ğŸ“‹ Cosa Testare Sapendo Questo
Carica script â†’ vanno nel DB del cliente
Crea 2 agent dello stesso cliente (o usa quelli che hai)
Modifica uno script â†’ ripulisci cache
Avvia call da Agent A â†’ usa il nuovo script
Avvia call da Agent B â†’ usa lo STESSO nuovo script
Se nei log vedi:

ğŸ“š [ScriptLoader] Fetching scripts from database for client abc123...
ğŸ“š [ScriptLoader] Found 3 active scripts for client abc123

Significa che TUTTI i tuoi agent stanno usando gli stessi 3 script dal DB.

Chiaro? O vuoi che cambio il sistema affinchÃ© ogni agent abbia script propri?