Dai log si vede chiarissimo perchÃ© â€œesce dal toolâ€:

1Â° turno: classifier â†’ booking_request âœ… â†’ tool mode âœ… â†’ Gemini chiama getAvailableSlots âœ…

2Â° turno: il sistema ricade in intent: general e riattiva codeExecution/fileSearch âœ…âŒ
(e infatti non si vede piÃ¹ la sezione â€œIntent classifier request/responseâ€, nÃ© â€œFUNCTION CALLING MODE ACTIVEâ€)

Quindi il problema non Ã¨ Gemini, Ã¨ il tuo router che al follow-up non mantiene il â€œbooking flowâ€.

Sotto ti elenco i 3 bug/edge-case principali (uno Ã¨ proprio un bug di codice) + le patch pratiche.

1) BUG grosso: proposeBooking non salva conversation_id in pending_bookings

Nel tuo consultation-tool-executor.ts, quando fai lâ€™INSERT:

await db.insert(pendingBookings).values({
  token: confirmationToken,
  clientId,
  consultantId,
  startAt: proposedDateTime,
  duration: args.duration || 60,
  status: "awaiting_confirm",
  notes: args.notes,
  expiresAt,
});


mancano conversationId e publicConversationId.

Impatti:

getPendingBookingState(conversationId, ...) â†’ torna sempre null

confirmBooking fallback â€œsenza token ma con conversationIdâ€ â†’ non troverÃ  mai nulla

â€œsticky tool modeâ€ basato su pending booking â†’ non scatterÃ  mai

âœ… Fix: passa conversationId al tool executor (server-side, non farlo scegliere al modello) e salvalo nellâ€™INSERT.

Esempio:

ai-service.ts (quando chiami executeConsultationTool):

const toolResult = await executeConsultationTool(
  functionCall.name,
  functionCall.args,
  clientId,
  consultantId,
  conversationId // <â€”
);


consultation-tool-executor.ts (firma + INSERT):

export async function executeConsultationTool(
  toolName: string,
  args: Record<string, any>,
  clientId: string,
  consultantId: string,
  conversationId?: string | null
) { ... }

await db.insert(pendingBookings).values({
  token: confirmationToken,
  clientId,
  consultantId,
  startAt: proposedDateTime,
  duration: args.duration || 60,
  status: "awaiting_confirm",
  conversationId: conversationId ?? null,  // <â€”
  notes: args.notes,
  expiresAt,
});

2) Problema logico: tra â€œmostro gli slotâ€ e â€œproposeBookingâ€ non esiste alcuno stato

Nel 1Â° turno Gemini mostra gli slot. In quel momento non câ€™Ã¨ ancora pending booking (giusto).
Se lâ€™utente poi risponde con qualcosa tipo:

â€œokâ€

â€œva beneâ€

â€œsÃ¬ grazieâ€
â€¦il classifier spesso lo interpreta come booking_confirm, ma tu blocchi booking_confirm senza pending token â†’ isConsultationQuery diventa false â†’ il router torna â€œgeneralâ€ â†’ addio tools.

âœ… Fix â€œproductionâ€: serve uno stato prima del pending booking:

booking_stage = awaiting_slot_selection (con TTL tipo 10â€“20 min)

viene settato quando hai appena mostrato gli slot

Puoi farlo in modo minimale:

aggiungi un record su DB (o JSON su aiConversations) tipo:

active_flow = 'consultations_booking'

stage = 'awaiting_slot_selection'

expires_at

E poi nel router:

se stage=awaiting_slot_selection â†’ classifier sempre + non uscire mai dai consultation tools, anche senza pending token.

Questo Ã¨ ESATTAMENTE il â€œmissing linkâ€ che ti fa scappare al secondo messaggio.

3) Regex â€œok/sÃ¬â€ troppo rigida + non gestisci â€œbooking_confirm senza pendingâ€

Hai giÃ  messo ^ok$, ^si$, ^sÃ¬$â€¦ ma nella realtÃ  lâ€™utente scrive:

â€œok grazieâ€

â€œsÃ¬ va beneâ€

â€œperfetto alloraâ€
Questi non matchano gli anchor ^...$, quindi spesso shouldRunClassifier non parte proprio â†’ finisci in â€œgeneralâ€ (come nel log).

âœ… Fix minimo: togli gli anchor e rendi i match â€œa parolaâ€:

const potentialConsultationKeywords =
  /\b(incontri|call|slot|appuntament|prenotare|disponibil|limite|sessioni|conferm|ok|si|sÃ¬|perfetto|va bene|procedi|prenota)\b/i;


âœ… Fix migliore (logico): se classifier ritorna booking_confirm ma non hai pending, NON devi uscire dal flow. Devi rispondere:

â€œPerfetto â€” dimmi quale slot vuoi (es: â€˜giovedÃ¬ 5 febbraio alle 09:00â€™)â€

Questa Ã¨ una regola router, non del modello.

Esempio (ai-service.ts):

if (
  consultationIntentClassification?.intent === 'booking_confirm' &&
  !classifierContext.hasPendingBooking
) {
  // resti in booking flow ma chiedi slot
  isConsultationQuery = true;
  clarificationNeeded = true;
  clarificationPrompt = "Ok! Quale slot preferisci? Scrivimi giorno e ora (es: â€œgiovedÃ¬ 5 febbraio alle 09:00â€).";
}


ğŸ”´ Nota: oggi clarificationNeeded/clarificationPrompt li logghi ma non li usi per rispondere. Se vuoi davvero che funzioni, quando clarificationNeeded=true devi ritornare subito quel prompt (senza tool call).

4) Extra: per sicurezza non fare fallback â€œse filteredTools Ã¨ vuoto â†’ dai tutti i toolâ€

Nel tuo ai-service hai:

clientTools = [{ functionDeclarations: filteredTools.length > 0 ? filteredTools : consultationTools }];


Se per qualsiasi motivo allowedTools=[], stai esponendo tutti i tool. Ãˆ un rischio inutile.

Meglio:

se filteredTools.length === 0 â†’ nessun tool + domanda di chiarimento
oppure

esponi solo un set safe (getAvailableSlots).

In breve: cosa fare adesso (ordine consigliato)

Fix immediato (bug): salva conversation_id in pending_bookings (e passa conversationId al tool executor)

Fix logico: aggiungi awaiting_slot_selection (sticky flow anche prima del pending)

Fix router: se booking_confirm ma manca pending â†’ resta nel flow e chiedi lo slot

Fix regex: elimina gli anchor ^ok$ / ^si$ e gestisci â€œok grazieâ€ ecc.