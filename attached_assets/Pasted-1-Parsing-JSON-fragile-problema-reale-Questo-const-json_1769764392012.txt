1Ô∏è‚É£ Parsing JSON fragile (problema reale)

Questo:

const jsonMatch = text.match(/\{[\s\S]*\}/);


√à pericoloso.

Perch√©?

Se Gemini scrive:

Here is the result:
{...}
Thanks!


Regex prende TUTTO fino all‚Äôultima graffa.

Versione robusta (consigliata)

Usa delimitatore esplicito:

Nel prompt:

Aggiungi:

Wrap the JSON output between <json> and </json> tags.

Parsing:
const match = text.match(/<json>([\s\S]*?)<\/json>/);

if (!match) throw new Error("No JSON block");

const parsed = JSON.parse(match[1]);


üëâ Questo √® pattern standard OpenAI + Gemini interno.

2Ô∏è‚É£ Manca system role (stai usando user role)

Ora fai:

role: 'user'


Dovresti separare:

CORRETTO:
contents: [
  {
    role: 'system',
    parts: [{ text: INTENT_CLASSIFICATION_PROMPT }]
  },
  {
    role: 'user',
    parts: [{ text: message }]
  }
]

Perch√© √® importante?

Riduce drift

Riduce injection

Migliora stabilit√† output

3Ô∏è‚É£ Prompt troppo ‚Äúdebole‚Äù sulle regole

Aggiungi queste 3 righe fondamentali:

Rules:
- Output MUST be valid JSON
- Do NOT add explanations outside JSON
- If unsure, choose "other" with low confidence


Questo aumenta precisione del 10‚Äì15%.

4Ô∏è‚É£ Confidence logic: migliora

Ora:

>= 0.7


Buono, ma puoi fare meglio:

Pattern production:
if (confidence >= 0.8) auto
if (0.5‚Äì0.79) ask clarification
if <0.5 ignore tools

Esempio:

Utente:

voglio vedere se posso fare qualcosa domani

Confidence 0.62

üëâ Gemini dovrebbe chiedere:

Intendi prenotare una consulenza?

NON chiamare tool.

5Ô∏è‚É£ getToolsForIntent ha un problema semantico

Questo:

booking_request ‚Üí ['getAvailableSlots', 'proposeBooking']


√à sbagliato concettualmente.

Perch√©?

Stai assumendo:

che servano entrambi

che debbano essere chiamati in sequenza

Ma l‚ÄôLLM √® l‚Äôorchestratore.

Pattern migliore:

Esporre SOLO tool primitivi:

Esempio:
booking_request:
  return ['getAvailableSlots', 'createBookingDraft']


E lasciare Gemini decidere:

prima slots

poi draft

NON forzare workflow lato router.

6Ô∏è‚É£ Manca memory safety

Ora booking_confirm:

return ['confirmBooking']


Ma confirm cosa?

üëâ Devi passare:

booking_id

slot_id

Se non ci sono:

Devi bloccare tool usage:
if (!context.pendingBookingId) return []


Altrimenti Gemini inventa ID.

7Ô∏è‚É£ Logging: ottimo ma manca trace id

Ora:

console.log üéØ


In produzione aggiungi:

request_id
user_id
session_id


Cos√¨ puoi:

debuggare

ricostruire conversazioni

fare audit AI

Versione architetturale IDEALE

Ti scrivo la pipeline target:

User Message
   ‚Üì
Intent Classifier (no tools)
   ‚Üì
Confidence Gate
   ‚Üì
Context Validator (do I have booking_id?)
   ‚Üì
Tool Exposure Filter
   ‚Üì
Gemini Tool Call (AUTO)
   ‚Üì
Backend Execution
   ‚Üì
Structured Response
   ‚Üì
Gemini Final Message