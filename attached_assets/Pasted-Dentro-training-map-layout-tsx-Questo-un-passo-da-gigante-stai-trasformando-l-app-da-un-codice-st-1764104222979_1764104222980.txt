Dentro training map layout.tsx Questo √® un passo da gigante: stai trasformando l'app da un codice statico a un vero e proprio CMS per Script di Vendita.

L'idea √® eccellente: invece di modificare file .ts o .json complessi, avrai un'interfaccia visuale dove puoi modificare "Step 1", "Domanda Chiave", ecc., e salvare diverse versioni (es. "Script Aggressivo", "Script Empatico") per testarle.

Ecco il piano operativo per realizzare il "Sales Script Manager":

Database (Il Cuore): Dobbiamo creare una tabella sales_scripts nel database. Attualmente gli script sono hardcoded nel codice. Dobbiamo spostarli nel DB per renderli modificabili. Migrazione Dati: Prender√≤ gli script attuali (che sono nel file server/ai/sales-scripts-base.ts) e li inserir√≤ nel database come "Versione 1.0 (Default)", cos√¨ non perdi nulla. Backend API: Creer√≤ le rotte per leggere, salvare e impostare come "Attivo" uno script specifico. Frontend (L'Editor): Creer√≤ la pagina che chiedi. Non sar√† un semplice blocco di testo, ma un Editor a Blocchi: Vedrai la lista degli step sulla sinistra. Cliccando su uno step, modifichi il contenuto (Obiettivo, Domande) a destra. Il sistema parsa automaticamente le modifiche per mantenere sincronizzato il JSON. Hot-Swap AI: Modificher√≤ il "cervello" dell'AI (sales-agent-context-builder.ts) per fargli leggere lo script dal database invece che dal file. Iniziamo subito creando la struttura dati necessaria. Creer√≤ una tabella che supporta versioni multiple e la distinzione tra Discovery, Demo e Obiezioni.

Eseguo la migrazione del database.Generata la migrazione per la tabella sales_scripts.

Ora applico la migrazione al database per creare effettivamente la tabella.La tabella sales_scripts √® pronta.

Ora non vogliamo partire da zero. Prender√≤ gli script attuali (Discovery, Demo e Obiezioni) che sono hardcoded nel file server/ai/sales-scripts-base.ts e li salver√≤ nel database come prima versione.

In questo modo, quando aprirai l'editor, troverai gi√† tutto il tuo materiale pronto per essere modificato.

Sto creando uno script di seed che:

Legge le funzioni da sales-scripts-base.ts. Legge la struttura JSON da sales-script-structure.json. Salva tutto nel DB. Nota: Poich√© non posso eseguire direttamente le funzioni TS del server in questo contesto di script isolato senza compilare tutto, estrarr√≤ il testo direttamente dai file per inserirlo nel DB.

Procedo con la creazione dello script di popolamento.Ho creato lo script di seed server/scripts/seed-sales-scripts.ts. Questo script estrarr√† il contenuto attuale dagli script hardcoded e li inserir√† nel database, creando una "Versione Base" attiva per:

Discovery Call Demo Call Gestione Obiezioni Ora eseguo questo script per popolare il database.I dati sono stati inseriti correttamente! üéâ

Abbiamo:

‚úÖ Discovery Call: Salvata e attiva. ‚úÖ Demo Call: Salvata e attiva. ‚úÖ Gestione Obiezioni: Salvata e attiva. Ora che i dati sono nel DB, dobbiamo creare le API per permettere al frontend di leggerli e modificarli.

Inoltre, dobbiamo assicurarci che quando modifichi il testo dello script, il sistema aggiorni automaticamente la struttura JSON (quella che serve per l'analisi "domanda per domanda"). Ho visto che esiste gi√† un parser (sales-script-structure-parser.ts), quindi lo useremo nelle API.

Creo il file delle rotte: server/routes/sales-scripts.ts.Ho creato le API in server/routes/sales-scripts.ts. Ecco cosa puoi fare ora:

GET /api/sales-scripts: Ottieni la lista di tutti gli script. GET /api/sales-scripts/:id: Leggi uno script specifico. POST /api/sales-scripts: Crea una nuova versione di uno script (salva il testo E rigenera automaticamente la struttura JSON usando il parser). POST /api/sales-scripts/:id/activate: Rendi attivo uno script (es. passi dalla v1 alla v2). Ora devo registrare queste nuove rotte nel file principale server/routes.ts affinch√© il server le riconosca.Ho registrato le rotte. Il backend √® pronto.

Ora la parte divertente. Costruiamo l'interfaccia.

Creer√≤ una nuova pagina: /consultant/script-manager.

Design della Pagina:

Sidebar Sinistra: Lista degli script (Discovery, Demo, Obiezioni) e le loro versioni. Area Centrale (Editor Visuale): Non ti dar√≤ solo un muro di testo. User√≤ la struttura JSON per mostrarti lo script diviso in blocchi (Steps). Potrai cliccare su uno step (es. "Fase 2: Qualificazione") e modificare il testo di quella specifica sezione. Un pulsante "Salva Nuova Versione" per non sovrascrivere l'originale per errore. Inizio creando i componenti per il Frontend. Partiamo dalla pagina principale client/src/pages/consultant-script-manager.tsx.Ho creato la struttura base del Script Manager.

Ora devo creare i componenti interni per rendere l'editor funzionale e intuitivo:

ScriptEditor.tsx: Il cuore della pagina. Gestir√† la visualizzazione del testo e la modifica. ScriptVersionList.tsx: Per vedere la cronologia delle versioni e attivare quella che vuoi usare. Per l'editor, user√≤ un approccio ibrido intelligente:

Mostrer√≤ l'anteprima strutturata (i "blocchi" che volevi vedere: Step, Obiettivi, Domande). Quando clicchi su "Modifica", ti permetter√≤ di editare il testo Markdown di quella sezione. Procedo a creare client/src/components/scripts/ScriptEditor.tsx.Ho creato l'editor. √à progettato per essere molto potente:

Modalit√† Visuale: Vedi lo script diviso in step colorati. Vedi chiaramente gli obiettivi e le domande chiave. Modalit√† Raw (Testo): Puoi modificare direttamente il testo grezzo se devi fare copia-incolla veloci. Salvataggio Versioni: Quando salvi, ti chiede se vuoi sovrascrivere (solo bozza) o creare una nuova versione (consigliato). Ora manca l'ultimo pezzo: aggiornare la navigazione per includere questa nuova pagina e permetterti di accedervi.

Aggiungo il link "Script Manager" alla sidebar (client/src/components/layout/MomentumSidebar.tsx) e configuro la rotta in client/src/App.tsx.Ho aggiornato la sidebar e le rotte.

Abbiamo creato il sistema di gestione, ma l'AI sta ancora leggendo i vecchi file hardcoded!

Dobbiamo modificare server/ai/sales-agent-context-builder.ts per dirgli: "Ehi, non leggere pi√π le stringhe fisse. Vai nel database, cerca lo script ATTIVO per questo tipo di call, e usa quello".

Questo √® il passaggio che abilita il "Hot-Swap": tu modifichi il frontend, salvi, e alla prossima chiamata l'AI usa il nuovo script.

Procedo con la modifica di server/ai/sales-agent-context-builder.ts.Ho completato la modifica critica al "cervello" dell'AI.

Cosa succede ora:

Quando parte una chiamata (o una simulazione), sales-agent-context-builder.ts interroga il database. Cerca lo script attivo per il tipo di chiamata corrente (discovery, demo o objections). Se lo trova, inietta quel contenuto nel prompt di sistema di Gemini. Se non lo trova (caso di fallback), usa ancora i vecchi default per sicurezza. Hai ora un sistema CMS completo per i tuoi script di vendita.

Come usarlo:

Nel menu laterale, clicca su "Script Manager" (icona del file/testo). Seleziona lo script che vuoi modificare (es. "Discovery Call"). Vedrai lo script attuale diviso in blocchi. Clicca su "Modifica Script" in alto a destra. Fai le tue modifiche (es. cambia una domanda, aggiungi un'istruzione). Clicca "Salva Modifiche". Il sistema creer√† una nuova versione, parser√† automaticamente la struttura (per aggiornare i grafici e le analisi) e la render√† attiva.